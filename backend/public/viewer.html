<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Argus – Document Viewer</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
      body {
        margin: 0;
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
          sans-serif;
        background: #f3f4f6;
        color: #111827;
      }
      .viewer-container {
        display: flex;
        flex-direction: column;
        height: 100vh;
      }
      .viewer-header {
        padding: 0.6rem 0.9rem;
        background: #111827;
        color: #e5e7eb;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }
      .viewer-title {
        font-size: 0.95rem;
        font-weight: 600;
      }
      .viewer-meta {
        font-size: 0.8rem;
        opacity: 0.9;
      }
      .viewer-status {
        padding: 0.5rem 0.9rem;
        font-size: 0.85rem;
      }
      .viewer-status.error {
        color: #b91c1c;
      }
      .viewer-controls {
        padding: 0 0.9rem 0.4rem;
        display: flex;
        align-items: center;
        gap: 0.5rem;
        font-size: 0.85rem;
      }
      .viewer-controls button {
        padding: 0.25rem 0.6rem;
        border-radius: 4px;
        border: 1px solid #d1d5db;
        background: #e5e7eb;
        cursor: pointer;
      }
      .viewer-controls button:disabled {
        background: #f3f4f6;
        color: #9ca3af;
        cursor: default;
      }
      .viewer-frame-wrapper {
        flex: 1 1 auto;
        background: #111827;
        display: flex;
        justify-content: flex-start;
        align-items: flex-start;
        overflow: auto;
        padding: 0.5rem;
      }
      .viewer-doc {
        flex: 1 1 auto;
        display: flex;
        justify-content: center;
      }
      .viewer-comments {
        flex: 0 0 260px;
        max-width: 320px;
        margin-left: 0.75rem;
        background: #f9fafb;
        border-radius: 4px;
        padding: 0.5rem 0.6rem;
        box-shadow: 0 0 4px rgba(0, 0, 0, 0.15);
        display: flex;
        flex-direction: column;
        height: 100%;
        box-sizing: border-box;
      }
      .comments-header {
        font-size: 0.85rem;
        font-weight: 600;
        color: #374151;
        margin-bottom: 0.35rem;
      }
      .comments-body {
        flex: 1 1 auto;
        overflow-y: auto;
        font-size: 0.85rem;
      }
      .comments-input {
        margin-top: 0.35rem;
        border-top: 1px solid #e5e7eb;
        padding-top: 0.35rem;
        display: flex;
        flex-direction: column;
        gap: 0.25rem;
      }
      .comments-input textarea {
        width: 100%;
        min-height: 3rem;
        resize: vertical;
        padding: 0.3rem 0.4rem;
        border-radius: 4px;
        border: 1px solid #d1d5db;
        font: inherit;
        box-sizing: border-box;
      }
      .comments-input-footer {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 0.25rem;
        font-size: 0.8rem;
      }
      .comments-input-footer input[type='text'] {
        flex: 0 0 80px;
        max-width: 120px;
        padding: 0.2rem 0.35rem;
        border-radius: 4px;
        border: 1px solid #d1d5db;
        font: inherit;
        box-sizing: border-box;
      }
      .comments-input-footer button {
        padding: 0.25rem 0.6rem;
        border-radius: 4px;
        border: 1px solid #15803d;
        background: #15803d;
        color: #ffffff;
        cursor: pointer;
      }
      .comments-input-footer button:disabled {
        background: #9ca3af;
        border-color: #9ca3af;
        cursor: default;
      }
      .comments-input-error {
        color: #b91c1c;
        font-size: 0.75rem;
      }
      .comment-empty {
        color: #6b7280;
        font-style: italic;
      }
      .comment-item {
        margin-bottom: 0.5rem;
        padding-bottom: 0.35rem;
        border-bottom: 1px solid #e5e7eb;
      }
      .comment-item:last-child {
        border-bottom: none;
        padding-bottom: 0;
      }
      .comment-meta {
        font-size: 0.75rem;
        color: #6b7280;
        margin-bottom: 0.15rem;
      }
      #pdf-canvas {
        background: #ffffff;
        box-shadow: 0 0 8px rgba(0, 0, 0, 0.4);
        max-width: 100%;
        height: auto;
      }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
    <script>
      if (window['pdfjsLib']) {
        pdfjsLib.GlobalWorkerOptions.workerSrc =
          'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js';
      }
    </script>
  </head>
  <body>
    <div class="viewer-container">
      <div class="viewer-header">
        <div class="viewer-title">Argus – Document Viewer</div>
        <div class="viewer-meta" id="viewer-meta"></div>
      </div>
      <div id="viewer-status" class="viewer-status">Loading PDF…</div>
      <div class="viewer-controls">
        <button id="prev-page-btn" disabled>Prev</button>
        <span id="page-indicator">Page 1 / 1</span>
        <button id="next-page-btn" disabled>Next</button>
      </div>
      <div class="viewer-frame-wrapper">
        <div class="viewer-doc">
          <canvas id="pdf-canvas"></canvas>
        </div>
        <aside class="viewer-comments">
          <div class="comments-header">Comments</div>
          <div id="comments-body" class="comments-body"></div>
          <div class="comments-input">
            <textarea
              id="comment-text"
              placeholder="Add a comment for this page..."
            ></textarea>
            <div class="comments-input-footer">
              <div>
                <label for="comment-author">Initials</label>
                <input
                  type="text"
                  id="comment-author"
                  maxlength="4"
                  placeholder="AB"
                />
              </div>
              <div style="display: flex; flex-direction: column; align-items: flex-end; gap: 0.1rem;">
                <button id="comment-submit-btn" disabled>Add comment</button>
                <div id="comment-error" class="comments-input-error"></div>
              </div>
            </div>
          </div>
        </aside>
      </div>
    </div>

    <script>
      (async function initViewer() {
        const statusEl = document.getElementById('viewer-status');
        const canvasEl = document.getElementById('pdf-canvas');
        const metaEl = document.getElementById('viewer-meta');
        const prevBtn = document.getElementById('prev-page-btn');
        const nextBtn = document.getElementById('next-page-btn');
        const pageIndicator = document.getElementById('page-indicator');
        const commentsBody = document.getElementById('comments-body');
        const commentTextInput = document.getElementById('comment-text');
        const commentAuthorInput = document.getElementById('comment-author');
        const commentSubmitBtn = document.getElementById('comment-submit-btn');
        const commentErrorEl = document.getElementById('comment-error');

        let pdfDoc = null;
        let currentPage = 1;
        let totalPages = 0;
        let isRendering = false;
        let pendingPage = null;
        let allComments = [];
        let currentDocId = '';

        function setStatus(message, isError) {
          if (!statusEl) return;
          statusEl.textContent = message;
          statusEl.className = isError ? 'viewer-status error' : 'viewer-status';
        }

        function updateControls() {
          if (pageIndicator && totalPages > 0) {
            pageIndicator.textContent = `Page ${currentPage} / ${totalPages}`;
          }
          if (prevBtn) {
            prevBtn.disabled = currentPage <= 1 || totalPages === 0;
          }
          if (nextBtn) {
            nextBtn.disabled =
              totalPages === 0 || currentPage >= totalPages;
          }
        }

        function renderCommentsForPage(pageNum) {
          if (!commentsBody) return;
          commentsBody.innerHTML = '';

          if (!Array.isArray(allComments) || allComments.length === 0) {
            const empty = document.createElement('div');
            empty.className = 'comment-empty';
            empty.textContent = 'No comments for this document.';
            commentsBody.appendChild(empty);
            return;
          }

          const filtered = allComments.filter(
            (c) => c.pageNumber === pageNum,
          );

          if (filtered.length === 0) {
            const empty = document.createElement('div');
            empty.className = 'comment-empty';
            empty.textContent = 'No comments for this page.';
            commentsBody.appendChild(empty);
            return;
          }

          for (const c of filtered) {
            const item = document.createElement('div');
            item.className = 'comment-item';

            const meta = document.createElement('div');
            meta.className = 'comment-meta';
            const parts = [];
            parts.push(`Page ${c.pageNumber}`);
            if (c.author) {
              parts.push(`by ${c.author}`);
            }
            meta.textContent = parts.join(' • ');
            item.appendChild(meta);

            const textDiv = document.createElement('div');
            textDiv.textContent = c.text;
            item.appendChild(textDiv);

            commentsBody.appendChild(item);
          }
        }

        async function loadComments(docId) {
          currentDocId = docId;
          if (!commentsBody) return;
          try {
            const res = await fetch(
              `/api/documents/${encodeURIComponent(docId)}/comments`,
            );
            let json = null;
            try {
              json = await res.json();
            } catch {
              json = null;
            }
            if (!res.ok || !json || !Array.isArray(json.items)) {
              console.error(
                'Failed to load comments:',
                json && json.error ? json.error : res.status,
              );
              return;
            }

            allComments = json.items.map((row) => ({
              id: row.id,
              pageNumber: Number(row.pageNumber) || 1,
              text: row.text || '',
              author: row.author || '',
            }));

            renderCommentsForPage(currentPage);
          } catch (err) {
            console.error('Error loading comments:', err);
          }
        }

        function updateCommentSubmitState() {
          if (!commentSubmitBtn || !commentTextInput) return;
          const text =
            typeof commentTextInput.value === 'string'
              ? commentTextInput.value.trim()
              : '';
          commentSubmitBtn.disabled = text.length === 0 || !currentDocId;
        }

        async function renderPage(pageNum) {
          if (!pdfDoc || !canvasEl) return;
          if (isRendering) {
            pendingPage = pageNum;
            return;
          }

          isRendering = true;
          setStatus(`Loading page ${pageNum}…`, false);

          try {
            const page = await pdfDoc.getPage(pageNum);
            const viewport = page.getViewport({ scale: 1.2 });
            const context = canvasEl.getContext('2d');
            if (!context) {
              setStatus('Unable to get canvas context.', true);
              isRendering = false;
              return;
            }

            canvasEl.width = viewport.width;
            canvasEl.height = viewport.height;

            const renderContext = {
              canvasContext: context,
              viewport,
            };

            await page.render(renderContext).promise;
            currentPage = pageNum;
            setStatus('', false);
          } catch (renderErr) {
            console.error('Error rendering PDF page:', renderErr);
            setStatus(
              'Failed to render PDF in viewer. See console for details.',
              true,
            );
          } finally {
            isRendering = false;
            updateControls();
            if (pendingPage !== null && pendingPage !== currentPage) {
              const next = pendingPage;
              pendingPage = null;
              renderPage(next);
            } else {
              pendingPage = null;
            }

            renderCommentsForPage(currentPage);
          }
        }

        try {
          const params = new URLSearchParams(window.location.search);
          const docId = (params.get('doc') || '').trim();
          if (!docId) {
            setStatus('Missing document id (?doc=...).', true);
            return;
          }

          if (metaEl) {
            metaEl.textContent = `Document: ${docId}`;
          }

          setStatus('Fetching pre-signed URL…', false);

          const res = await fetch(
            `/api/documents/${encodeURIComponent(docId)}/presigned-url`,
          );

          let json = null;
          try {
            json = await res.json();
          } catch {
            json = null;
          }

          if (!res.ok || !json || typeof json.url !== 'string') {
            const message =
              json && json.error
                ? json.error
                : `Failed to load PDF (status ${res.status}).`;
            setStatus(message, true);
            return;
          }

          const url = json.url;
          if (!canvasEl) {
            setStatus('Viewer canvas is not available.', true);
            return;
          }

          if (!window['pdfjsLib']) {
            setStatus('PDF viewer library is not available.', true);
            return;
          }

          try {
            const pdfjsLib = window['pdfjsLib'];
            const loadingTask = pdfjsLib.getDocument({ url });
            pdfDoc = await loadingTask.promise;
            totalPages = typeof pdfDoc.numPages === 'number' ? pdfDoc.numPages : 0;
            await renderPage(1);
            // Load comments after initial render so we can show page 1 comments.
            await loadComments(docId);
          } catch (renderErr) {
            console.error('Error rendering PDF:', renderErr);
            setStatus(
              'Failed to render PDF in viewer. See console for details.',
              true,
            );
          }

          if (prevBtn) {
            prevBtn.addEventListener('click', () => {
              if (currentPage > 1) {
                renderPage(currentPage - 1);
              }
            });
          }

          if (nextBtn) {
            nextBtn.addEventListener('click', () => {
              if (totalPages && currentPage < totalPages) {
                renderPage(currentPage + 1);
              }
            });
          }

          updateControls();

          if (commentTextInput) {
            commentTextInput.addEventListener('input', () => {
              if (commentErrorEl) {
                commentErrorEl.textContent = '';
              }
              updateCommentSubmitState();
            });
          }

          if (commentSubmitBtn) {
            commentSubmitBtn.addEventListener('click', async () => {
              if (!commentTextInput || !currentDocId) return;
              const text = commentTextInput.value.trim();
              if (!text) {
                if (commentErrorEl) {
                  commentErrorEl.textContent = 'Comment text is required.';
                }
                updateCommentSubmitState();
                return;
              }

              const author =
                commentAuthorInput && commentAuthorInput.value
                  ? commentAuthorInput.value.trim()
                  : '';

              try {
                commentSubmitBtn.disabled = true;
                if (commentErrorEl) {
                  commentErrorEl.textContent = '';
                }

                const res = await fetch(
                  `/api/documents/${encodeURIComponent(
                    currentDocId,
                  )}/comments`,
                  {
                    method: 'POST',
                    headers: {
                      'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                      pageNumber: currentPage,
                      text,
                      author: author || undefined,
                    }),
                  },
                );

                let json = null;
                try {
                  json = await res.json();
                } catch {
                  json = null;
                }

                if (!res.ok) {
                  const msg =
                    json && json.error
                      ? json.error
                      : `Failed to save comment (status ${res.status}).`;
                  if (commentErrorEl) {
                    commentErrorEl.textContent = msg;
                  }
                  updateCommentSubmitState();
                  return;
                }

                const newComment = {
                  id: json.id,
                  pageNumber: currentPage,
                  text,
                  author: author || '',
                };
                allComments.push(newComment);

                commentTextInput.value = '';
                updateCommentSubmitState();
                renderCommentsForPage(currentPage);
              } catch (err) {
                console.error('Error saving comment:', err);
                if (commentErrorEl) {
                  commentErrorEl.textContent =
                    'Unexpected error saving comment. See console for details.';
                }
              } finally {
                updateCommentSubmitState();
              }
            });
          }
        } catch (err) {
          console.error('Error initializing viewer:', err);
          setStatus(
            'Unexpected error loading PDF. See console for details.',
            true,
          );
        }
      })();
    </script>
  </body>
  </html>
