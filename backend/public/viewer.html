<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Argus – Document Viewer</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
      body {
        margin: 0;
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
          sans-serif;
        background: #f3f4f6;
        color: #111827;
      }
      .viewer-container {
        display: flex;
        flex-direction: column;
        height: 100vh;
      }
      .viewer-header {
        padding: 0.6rem 0.9rem;
        background: #111827;
        color: #e5e7eb;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }
      .viewer-title {
        font-size: 0.95rem;
        font-weight: 600;
      }
      .viewer-meta {
        font-size: 0.8rem;
        opacity: 0.9;
      }
      .viewer-status {
        padding: 0.5rem 0.9rem;
        font-size: 0.85rem;
      }
      .viewer-status.error {
        color: #b91c1c;
      }
      .viewer-controls {
        padding: 0 0.9rem 0.4rem;
        display: flex;
        align-items: center;
        gap: 0.5rem;
        font-size: 0.85rem;
      }
      .viewer-controls button {
        padding: 0.25rem 0.6rem;
        border-radius: 4px;
        border: 1px solid #d1d5db;
        background: #e5e7eb;
        cursor: pointer;
      }
      .viewer-controls button:disabled {
        background: #f3f4f6;
        color: #9ca3af;
        cursor: default;
      }
      .viewer-frame-wrapper {
        flex: 1 1 auto;
        background: #111827;
        display: flex;
        justify-content: flex-start;
        align-items: flex-start;
        overflow: auto;
        padding: 0.5rem;
      }
      .viewer-doc {
        flex: 1 1 auto;
        display: flex;
        justify-content: center;
      }
      .viewer-comments {
        flex: 0 0 390px;
        max-width: 480px;
        margin-left: 0.75rem;
        background: #f9fafb;
        border-radius: 4px;
        padding: 0.5rem 0.6rem;
        box-shadow: 0 0 4px rgba(0, 0, 0, 0.15);
        display: flex;
        flex-direction: column;
        height: 100%;
        box-sizing: border-box;
      }
      .comments-header {
        font-size: 0.85rem;
        font-weight: 600;
        color: #374151;
        margin-bottom: 0.35rem;
      }
      .comments-body {
        flex: 1 1 auto;
        overflow-y: auto;
        font-size: 0.85rem;
      }
      .comments-input {
        margin-top: 0.35rem;
        border-top: 1px solid #e5e7eb;
        padding-top: 0.35rem;
        display: flex;
        flex-direction: column;
        gap: 0.25rem;
        background: #111827;
        color: #f9fafb;
        border-radius: 4px;
        padding-left: 0.4rem;
        padding-right: 0.4rem;
      }
      .comments-input textarea {
        width: 100%;
        min-height: 3rem;
        resize: vertical;
        padding: 0.3rem 0.4rem;
        border-radius: 4px;
        border: 1px solid #374151;
        font: inherit;
        box-sizing: border-box;
        background: #111827;
        color: #f9fafb;
      }
      .comments-input-footer {
        display: flex;
        justify-content: flex-end;
        align-items: center;
        gap: 0.25rem;
        font-size: 0.8rem;
      }
      .comments-input-footer button {
        padding: 0.25rem 0.6rem;
        border-radius: 4px;
        border: 1px solid #15803d;
        background: #15803d;
        color: #ffffff;
        cursor: pointer;
      }
      .comments-input-footer button:disabled {
        background: #9ca3af;
        border-color: #9ca3af;
        cursor: default;
      }
      .comments-input-error {
        color: #fecaca;
        font-size: 0.75rem;
      }
      .comment-empty {
        color: #6b7280;
        font-style: italic;
      }
      .comment-item {
        margin-bottom: 0.5rem;
        padding-bottom: 0.35rem;
        border-bottom: 1px solid #e5e7eb;
        position: relative;
        padding-right: 1.2rem;
        padding-left: 0.5rem;
      }
      .comment-item:last-child {
        border-bottom: none;
        padding-bottom: 0;
      }
      .comment-item.comment-active {
        background: #eef2ff;
        border-radius: 4px;
        border-bottom-color: #4f46e5;
      }
      .comment-color-bar {
        position: absolute;
        top: 0;
        bottom: 0;
        left: 0;
        width: 5px;
        border-radius: 3px;
        background: transparent;
      }
      .comment-meta {
        font-size: 0.75rem;
        color: #6b7280;
        margin-bottom: 0.15rem;
      }
      .comments-selection-preview {
        margin-top: 0.25rem;
        padding: 0.25rem 0.35rem;
        border-radius: 4px;
        background: #1f2937;
        font-size: 0.75rem;
        color: #e5e7eb;
        max-height: 3.5rem;
        overflow: hidden;
      }
      .comments-selection-label {
        font-weight: 600;
        margin-bottom: 0.1rem;
      }
      .comments-selection-text {
        font-style: italic;
        color: #e5e7eb;
      }
      .comments-metadata-row {
        margin-top: 0.3rem;
        display: flex;
        flex-wrap: wrap;
        gap: 0.35rem;
        font-size: 0.8rem;
      }
      .comments-metadata-row label {
        display: flex;
        flex-direction: column;
        gap: 0.1rem;
        color: #f9fafb;
        font-weight: 600;
      }
      .comments-metadata-row select {
        min-width: 100px;
        padding: 0.15rem 0.3rem;
        border-radius: 4px;
        border: 1px solid #374151;
        font: inherit;
        background: #111827;
        color: #f9fafb;
      }
      .comment-highlight-preview {
        margin-top: 0.1rem;
        font-size: 0.78rem;
        color: #4b5563;
        font-style: italic;
      }
      .comment-badges {
        margin-top: 0.15rem;
        font-size: 0.75rem;
        color: #4b5563;
      }
      .comment-severity-badge {
        display: inline-flex;
        align-items: center;
        gap: 0.25rem;
        padding: 0.05rem 0.35rem;
        border-radius: 999px;
        font-size: 0.7rem;
        background: #111827;
        color: #ffffff;
        margin-bottom: 0.15rem;
      }
      .comment-delete {
        position: absolute;
        top: 0;
        right: 0;
        font-size: 0.75rem;
        color: #ffffff;
        cursor: pointer;
        border: none;
        background: #b91c1c;
        padding: 0 4px;
        border-radius: 4px;
      }
      .comments-toolbar {
        display: flex;
        gap: 0.25rem;
        align-items: center;
        margin-bottom: 0.35rem;
        font-size: 0.75rem;
        color: #374151;
      }
      .comments-toolbar-label {
        margin-right: 0.25rem;
      }
      .comments-color-swatch {
        width: 16px;
        height: 16px;
        border-radius: 4px;
        border: 1px solid #d1d5db;
        cursor: pointer;
        box-sizing: border-box;
      }
      .comments-color-swatch.active {
        outline: 2px solid #2563eb;
        outline-offset: 1px;
      }
      .comments-eraser-swatch {
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 0.7rem;
        background: #ffffff;
      }
      .comments-page-note-hint {
        margin-top: 0.25rem;
        font-size: 0.75rem;
        color: #d1d5db;
      }
      .viewer-doc {
        flex: 1 1 auto;
        display: flex;
        justify-content: center;
      }
      .pdf-page-container {
        position: relative;
        display: inline-block;
      }
      #pdf-canvas {
        background: #ffffff;
        box-shadow: 0 0 8px rgba(0, 0, 0, 0.4);
        max-width: 100%;
        height: auto;
        display: block;
      }
      .pdf-highlight-layer {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        pointer-events: none;
        z-index: 1;
      }
      .pdf-highlight-box {
        position: absolute;
        background: transparent;
        border-radius: 2px;
      }
      .pdf-severity-badge {
        position: absolute;
        font-size: 0.7rem;
        padding: 0.05rem 0.3rem;
        border-radius: 999px;
        background: #111827;
        color: #ffffff;
        pointer-events: none;
        white-space: nowrap;
      }
      .pdf-text-layer {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        pointer-events: auto;
        color: transparent;
        z-index: 2;
      }
      .pdf-text-layer span {
        position: absolute;
        white-space: pre;
        cursor: text;
        transform-origin: 0% 0%;
      }
      .selection-toolbar-btn {
        position: absolute;
        z-index: 3;
        padding: 0.1rem 0.4rem;
        font-size: 0.75rem;
        border-radius: 4px;
        border: 1px solid #6b7280;
        background: #f9fafb;
        color: #111827;
        cursor: pointer;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.25);
      }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
    <script>
      if (window['pdfjsLib']) {
        pdfjsLib.GlobalWorkerOptions.workerSrc =
          'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js';
      }
    </script>
  </head>
  <body>
    <div class="viewer-container">
      <div class="viewer-header">
        <div class="viewer-title">Argus – Document Viewer</div>
        <div class="viewer-meta" id="viewer-meta"></div>
      </div>
      <div id="viewer-status" class="viewer-status">Loading PDF…</div>
      <div class="viewer-controls">
        <button id="prev-page-btn" disabled>Prev</button>
        <span id="page-indicator">Page 1 / 1</span>
        <button id="next-page-btn" disabled>Next</button>
      </div>
      <div class="viewer-frame-wrapper">
        <div class="viewer-doc">
          <div class="pdf-page-container">
            <canvas id="pdf-canvas"></canvas>
            <div
              id="pdf-highlight-layer"
              class="pdf-highlight-layer"
            ></div>
            <div id="pdf-text-layer" class="pdf-text-layer"></div>
          </div>
        </div>
        <aside class="viewer-comments">
          <div class="comments-toolbar">
            <span class="comments-toolbar-label">Highlighter:</span>
            <div
              id="comment-color-1"
              class="comments-color-swatch"
              title="Highlighter 1"
            ></div>
            <div
              id="comment-color-2"
              class="comments-color-swatch"
              title="Highlighter 2"
            ></div>
            <div
              id="comment-color-3"
              class="comments-color-swatch"
              title="Highlighter 3"
            ></div>
            <div
              id="comment-color-4"
              class="comments-color-swatch"
              title="Highlighter 4"
            ></div>
            <div
              id="comment-color-5"
              class="comments-color-swatch"
              title="Highlighter 5"
            ></div>
            <div
              id="comment-eraser"
              class="comments-color-swatch comments-eraser-swatch"
              title="Clear color"
            >
              ×
            </div>
          </div>
          <div class="comments-header">Comments</div>
          <div id="comments-body" class="comments-body"></div>
          <div class="comments-input">
            <textarea
              id="comment-text"
              placeholder="Add a comment for this page..."
            ></textarea>
            <div
              id="comment-selection-preview"
              class="comments-selection-preview"
              style="display: none;"
            >
              <div class="comments-selection-label">Selection</div>
              <div
                id="comment-selection-text"
                class="comments-selection-text"
              ></div>
            </div>
            <div
              id="comment-page-note-hint"
              class="comments-page-note-hint"
            >
              No text selected — comment will apply to this page.
            </div>
            <div class="comments-metadata-row">
              <label for="comment-category">
                Category
                <select id="comment-category">
                  <option value="">(none)</option>
                  <option value="clinical risk">Clinical risk</option>
                  <option value="documentation">Documentation</option>
                  <option value="legal note">Legal note</option>
                  <option value="other">Other</option>
                </select>
              </label>
              <label for="comment-severity">
                Severity
                <select id="comment-severity">
                  <option value="">(none)</option>
                  <option value="low">Low</option>
                  <option value="medium">Medium</option>
                  <option value="high">High</option>
                </select>
              </label>
              <label for="comment-status">
                Status
                <select id="comment-status">
                  <option value="open">Open</option>
                  <option value="resolved">Resolved</option>
                </select>
              </label>
            </div>
            <div class="comments-input-footer">
              <div style="display: flex; flex-direction: column; align-items: flex-end; gap: 0.1rem;">
                <button id="comment-submit-btn" disabled>Add comment</button>
                <div id="comment-error" class="comments-input-error"></div>
              </div>
            </div>
          </div>
        </aside>
      </div>
    </div>

    <script>
      (async function initViewer() {
        const statusEl = document.getElementById('viewer-status');
        const canvasEl = document.getElementById('pdf-canvas');
        const metaEl = document.getElementById('viewer-meta');
        const prevBtn = document.getElementById('prev-page-btn');
        const nextBtn = document.getElementById('next-page-btn');
        const pageIndicator = document.getElementById('page-indicator');
        const commentsBody = document.getElementById('comments-body');
        const commentTextInput = document.getElementById('comment-text');
        const commentSubmitBtn = document.getElementById('comment-submit-btn');
        const commentErrorEl = document.getElementById('comment-error');
        const selectionPreviewEl = document.getElementById(
          'comment-selection-preview',
        );
        const selectionPreviewTextEl = document.getElementById(
          'comment-selection-text',
        );
        const pageNoteHintEl = document.getElementById(
          'comment-page-note-hint',
        );
        const commentCategorySelect = document.getElementById(
          'comment-category',
        );
        const commentSeveritySelect = document.getElementById(
          'comment-severity',
        );
        const commentStatusSelect = document.getElementById('comment-status');
        const textLayerEl = document.getElementById('pdf-text-layer');
        const highlightLayerEl = document.getElementById('pdf-highlight-layer');
        const colorSwatchEls = [
          document.getElementById('comment-color-1'),
          document.getElementById('comment-color-2'),
          document.getElementById('comment-color-3'),
          document.getElementById('comment-color-4'),
          document.getElementById('comment-color-5'),
        ];
        const eraserSwatchEl = document.getElementById('comment-eraser');

        let pdfDoc = null;
        let currentPage = 1;
        let totalPages = 0;
        let isRendering = false;
        let pendingPage = null;
        let allComments = [];
        let currentDocId = '';
        let currentSelection = null;
        let selectionToolbarEl = null;
        let currentUser = null;
        let activeCommentId = null;
        let editingCommentId = null;
        let highlightColors = [];
        let highlightOpacity = 0.35;
        let activeHighlightColor = null;

        function hexToRgba(hex, alpha) {
          if (typeof hex !== 'string') return null;
          let value = hex.trim();
          if (value.startsWith('#')) {
            value = value.slice(1);
          }
          if (value.length === 3) {
            value =
              value[0] +
              value[0] +
              value[1] +
              value[1] +
              value[2] +
              value[2];
          }
          if (value.length !== 6) return null;
          const r = parseInt(value.slice(0, 2), 16);
          const g = parseInt(value.slice(2, 4), 16);
          const b = parseInt(value.slice(4, 6), 16);
          if (
            Number.isNaN(r) ||
            Number.isNaN(g) ||
            Number.isNaN(b)
          ) {
            return null;
          }
          const a = typeof alpha === 'number' ? alpha : 0.35;
          return `rgba(${r}, ${g}, ${b}, ${a})`;
        }

        function getEffectiveHighlightColor(color) {
          const base =
            typeof color === 'string' && color.trim()
              ? color.trim()
              : highlightColors[0] || '#FACC15';
          const rgba = hexToRgba(base, highlightOpacity);
          return rgba || 'rgba(250, 204, 21, 0.35)';
        }

        function getColorIndexForCategory(categoryValue) {
          const value =
            typeof categoryValue === 'string'
              ? categoryValue.trim().toLowerCase()
              : '';
          if (!value) return -1;
          switch (value) {
            case 'clinical risk':
              return 0;
            case 'documentation':
              return 1;
            case 'legal note':
              return 2;
            case 'other':
              return 3;
            default:
              return -1;
          }
        }

        function applyCategoryColor(categoryValue) {
          const index = getColorIndexForCategory(categoryValue);
          if (index >= 0 && index < highlightColors.length) {
            setActiveHighlightIndex(index);
            updateHighlightPointerEvents();

            // If a comment is active, immediately recolor its highlights in
            // the viewer so the user sees the new category color right away.
            if (
              activeCommentId !== null &&
              Array.isArray(allComments) &&
              allComments.length > 0
            ) {
              const active = allComments.find(
                (c) =>
                  typeof c.id === 'number' &&
                  c.id === activeCommentId,
              );
              if (active) {
                active.color = highlightColors[index];
                renderHighlightsForPage(currentPage);
              }
            }
          }
        }

        function setActiveHighlightIndex(index) {
          activeHighlightColor =
            index >= 0 && index < highlightColors.length
              ? highlightColors[index]
              : null;
          colorSwatchEls.forEach((el, i) => {
            if (!el) return;
            if (i === index) {
              el.classList.add('active');
            } else {
              el.classList.remove('active');
            }
          });
          if (eraserSwatchEl) {
            if (activeHighlightColor === null) {
              eraserSwatchEl.classList.add('active');
            } else {
              eraserSwatchEl.classList.remove('active');
            }
          }
          if (typeof currentPage === 'number' && currentPage >= 1) {
            renderHighlightsForPage(currentPage);
          }
        }

        function updateHighlightPointerEvents() {
          if (!highlightLayerEl || !textLayerEl || !canvasEl) return;
          if (activeHighlightColor === null) {
            // Eraser mode: allow clicking highlights, disable text selection,
            // and show an eraser-like cursor over the page.
            highlightLayerEl.style.pointerEvents = 'auto';
            textLayerEl.style.pointerEvents = 'none';
            highlightLayerEl.style.cursor = 'crosshair';
            canvasEl.style.cursor = 'crosshair';
          } else {
            // Highlight mode: enable text selection, ignore highlight clicks,
            // and restore the default cursor.
            highlightLayerEl.style.pointerEvents = 'none';
            textLayerEl.style.pointerEvents = 'auto';
            highlightLayerEl.style.cursor = '';
            canvasEl.style.cursor = '';
          }
        }

        if (colorSwatchEls[0]) {
          colorSwatchEls[0].addEventListener('click', () => {
            setActiveHighlightIndex(0);
            updateHighlightPointerEvents();
          });
        }
        if (colorSwatchEls[1]) {
          colorSwatchEls[1].addEventListener('click', () => {
            setActiveHighlightIndex(1);
            updateHighlightPointerEvents();
          });
        }
        if (colorSwatchEls[2]) {
          colorSwatchEls[2].addEventListener('click', () => {
            setActiveHighlightIndex(2);
            updateHighlightPointerEvents();
          });
        }
        if (colorSwatchEls[3]) {
          colorSwatchEls[3].addEventListener('click', () => {
            setActiveHighlightIndex(3);
            updateHighlightPointerEvents();
          });
        }
        if (colorSwatchEls[4]) {
          colorSwatchEls[4].addEventListener('click', () => {
            setActiveHighlightIndex(4);
            updateHighlightPointerEvents();
          });
        }
        if (eraserSwatchEl) {
          eraserSwatchEl.addEventListener('click', () => {
            setActiveHighlightIndex(-1);
            updateHighlightPointerEvents();
          });
        }

        async function handleHighlightLayerErase(event) {
          if (activeHighlightColor !== null) {
            return;
          }
          const target = event.target;
          if (!(target instanceof HTMLElement)) {
            return;
          }
          const rectIndexAttr = target.dataset.rectIndex;
          if (rectIndexAttr === undefined) {
            return;
          }
          const rectIndex = Number.parseInt(rectIndexAttr, 10);
          if (!Number.isFinite(rectIndex)) {
            return;
          }

          const isPreview = target.dataset.preview === '1';

          if (isPreview) {
            if (
              !currentSelection ||
              !Array.isArray(currentSelection.rects) ||
              rectIndex < 0 ||
              rectIndex >= currentSelection.rects.length
            ) {
              return;
            }

            currentSelection.rects.splice(rectIndex, 1);

            if (
              !currentSelection.rects ||
              currentSelection.rects.length === 0
            ) {
              currentSelection = null;
              updateSelectionPreview();
            }

            renderHighlightsForPage(currentPage);
            return;
          }

          const commentIdAttr = target.dataset.commentId;
          if (!commentIdAttr) {
            return;
          }
          const commentId = Number.parseInt(commentIdAttr, 10);
          if (!Number.isFinite(commentId)) {
            return;
          }

          // Eraser only operates on the currently active comment's saved
          // highlights so comment-scoped actions do not affect others.
          if (
            activeCommentId === null ||
            typeof activeCommentId !== 'number' ||
            commentId !== activeCommentId
          ) {
            return;
          }

          const comment = allComments.find(
            (c) => Number.parseInt(String(c.id), 10) === commentId,
          );
          if (!comment || !Array.isArray(comment.rects)) {
            return;
          }
          if (rectIndex < 0 || rectIndex >= comment.rects.length) {
            return;
          }

          comment.rects.splice(rectIndex, 1);

          try {
            const res = await fetch(
              `/api/documents/${encodeURIComponent(
                currentDocId,
              )}/comments/${encodeURIComponent(commentId)}`,
              {
                method: 'PATCH',
                headers: {
                  'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                  rects: comment.rects,
                }),
              },
            );

            if (!res.ok && res.status !== 204) {
              console.error(
                'Failed to update comment rects:',
                res.status,
              );
              window.alert(
                'Failed to update highlight. Please try again.',
              );
              await loadComments(currentDocId);
              return;
            }

            renderHighlightsForPage(currentPage);
          } catch (err) {
            console.error('Error updating comment rects:', err);
            window.alert(
              'Unexpected error updating highlight. See console for details.',
            );
          }
        }

        if (highlightLayerEl) {
          highlightLayerEl.addEventListener('click', (event) => {
            void handleHighlightLayerErase(event);
          });
          highlightLayerEl.addEventListener('dblclick', (event) => {
            void handleHighlightLayerErase(event);
          });
        }

        function setStatus(message, isError) {
          if (!statusEl) return;
          statusEl.textContent = message;
          statusEl.className = isError ? 'viewer-status error' : 'viewer-status';
        }

        function updateControls() {
          if (pageIndicator && totalPages > 0) {
            pageIndicator.textContent = `Page ${currentPage} / ${totalPages}`;
          }
          if (prevBtn) {
            prevBtn.disabled = currentPage <= 1 || totalPages === 0;
          }
          if (nextBtn) {
            nextBtn.disabled =
              totalPages === 0 || currentPage >= totalPages;
          }
        }

        function setActiveComment(commentId) {
          if (
            typeof commentId === 'number' &&
            Number.isFinite(commentId) &&
            commentId > 0
          ) {
            activeCommentId = commentId;
            editingCommentId = commentId;
          } else {
            activeCommentId = null;
            editingCommentId = null;
          }

          if (commentsBody) {
            const items = commentsBody.querySelectorAll('.comment-item');
            items.forEach((el) => {
              if (!(el instanceof HTMLElement)) return;
              const idAttr = el.dataset.commentId;
              const idNum = idAttr
                ? Number.parseInt(idAttr, 10)
                : NaN;
              if (
                activeCommentId !== null &&
                Number.isFinite(idNum) &&
                idNum === activeCommentId
              ) {
                el.classList.add('comment-active');
              } else {
                el.classList.remove('comment-active');
              }
            });
          }

          renderHighlightsForPage(currentPage);

          if (editingCommentId !== null) {
            const active = allComments.find(
              (c) =>
                typeof c.id === 'number' && c.id === editingCommentId,
            );
            if (active) {
              if (commentTextInput) {
                commentTextInput.value = active.text || '';
              }
              if (commentCategorySelect) {
                commentCategorySelect.value = active.category || '';
              }
              if (commentSeveritySelect) {
                commentSeveritySelect.value = active.severity || '';
              }
              if (commentStatusSelect) {
                commentStatusSelect.value = active.status || 'open';
              }
              if (commentSubmitBtn) {
                commentSubmitBtn.textContent = 'Update comment';
              }

              if (active.color) {
                const idx = highlightColors.findIndex(
                  (c) =>
                    typeof c === 'string' &&
                    c.toLowerCase() === active.color.toLowerCase(),
                );
                if (idx >= 0) {
                  setActiveHighlightIndex(idx);
                } else {
                  activeHighlightColor = active.color;
                  colorSwatchEls.forEach((el) => {
                    if (el) el.classList.remove('active');
                  });
                  if (eraserSwatchEl) {
                    eraserSwatchEl.classList.remove('active');
                  }
                }
              }
            }
          } else {
            if (commentTextInput) {
              commentTextInput.value = '';
            }
            if (commentCategorySelect) {
              commentCategorySelect.value = '';
            }
            if (commentSeveritySelect) {
              commentSeveritySelect.value = '';
            }
            if (commentStatusSelect) {
              commentStatusSelect.value = 'open';
            }
            if (commentSubmitBtn) {
              commentSubmitBtn.textContent = 'Add comment';
            }
          }

          updateCommentSubmitState();
        }

        function renderHighlightsForPage(pageNum) {
          if (!highlightLayerEl || !canvasEl) return;
          highlightLayerEl.innerHTML = '';

          const width = canvasEl.width;
          const height = canvasEl.height;
          if (!width || !height) return;

          const filtered = Array.isArray(allComments)
            ? allComments.filter(
                (c) =>
                  c.pageNumber === pageNum &&
                  Array.isArray(c.rects) &&
                  c.rects.length > 0,
              )
            : [];

          const hasPreview =
            currentSelection &&
            currentSelection.pageNumber === pageNum &&
            Array.isArray(currentSelection.rects) &&
            currentSelection.rects.length > 0;

          if (filtered.length === 0 && !hasPreview) return;

          highlightLayerEl.style.width = `${width}px`;
          highlightLayerEl.style.height = `${height}px`;

          filtered.forEach((c) => {
            const rects = Array.isArray(c.rects) ? c.rects : [];
            const colorStyle = getEffectiveHighlightColor(c.color);
            rects.forEach((rect, rectIndex) => {
              if (
                !rect ||
                typeof rect.x !== 'number' ||
                typeof rect.y !== 'number' ||
                typeof rect.width !== 'number' ||
                typeof rect.height !== 'number'
              ) {
                return;
              }

              const box = document.createElement('div');
              box.className = 'pdf-highlight-box';
              box.style.background = colorStyle;
              if (
                activeCommentId !== null &&
                typeof c.id === 'number' &&
                c.id === activeCommentId
              ) {
                box.style.outline = '2px solid rgba(37, 99, 235, 0.8)';
              }
              box.style.left = `${rect.x * width}px`;
              box.style.top = `${rect.y * height}px`;
              box.style.width = `${rect.width * width}px`;
              box.style.height = `${rect.height * height}px`;
              if (typeof c.id !== 'undefined') {
                box.dataset.commentId = String(c.id);
                box.dataset.rectIndex = String(rectIndex);
              }
              highlightLayerEl.appendChild(box);
            });

            // Add a small severity/footnote badge near the first highlight
            // rect, slightly above and to the right of the highlighted text.
            if (
              c.severity &&
              Array.isArray(c.rects) &&
              c.rects.length > 0 &&
              Array.isArray(allComments) &&
              allComments.length > 0
            ) {
              const severityValue = String(c.severity).toLowerCase();
              let severitySymbol = '';
              if (severityValue === 'low') {
                severitySymbol = '●';
              } else if (severityValue === 'medium') {
                severitySymbol = '■';
              } else if (severityValue === 'high') {
                severitySymbol = '▲';
              }

              if (severitySymbol) {
                let footnoteNumber = null;
                const idx = allComments.findIndex(
                  (existing) =>
                    typeof existing.id === 'number' &&
                    typeof c.id === 'number' &&
                    existing.id === c.id,
                );
                if (idx >= 0) {
                  footnoteNumber = idx + 1;
                }

                const anchorRect = c.rects[0];
                if (
                  anchorRect &&
                  typeof anchorRect.x === 'number' &&
                  typeof anchorRect.y === 'number' &&
                  typeof anchorRect.width === 'number'
                ) {
                  const badge = document.createElement('div');
                  badge.className = 'pdf-severity-badge';
                  const labelParts = [];
                  if (footnoteNumber !== null) {
                    labelParts.push(String(footnoteNumber));
                  }
                  labelParts.push(severitySymbol);
                  badge.textContent = labelParts.join(' ');

                  const baseLeft = (anchorRect.x + anchorRect.width) * width;
                  const baseTop = anchorRect.y * height;
                  const offsetX = 4;
                  const offsetY = 10;
                  let left = baseLeft + offsetX;
                  let top = baseTop - offsetY;
                  if (top < 0) top = 0;
                  if (left > width - 40) {
                    left = width - 40;
                  }
                  badge.style.left = `${left}px`;
                  badge.style.top = `${top}px`;

                  highlightLayerEl.appendChild(badge);
                }
              }
            }
          });

          // Render live preview for the current selection, if it is on this page.
          if (hasPreview) {
            const previewColor = getEffectiveHighlightColor(
              activeHighlightColor,
            );
            currentSelection.rects.forEach((rect, rectIndex) => {
              if (
                !rect ||
                typeof rect.x !== 'number' ||
                typeof rect.y !== 'number' ||
                typeof rect.width !== 'number' ||
                typeof rect.height !== 'number'
              ) {
                return;
              }
              const box = document.createElement('div');
              box.className = 'pdf-highlight-box';
              box.style.background = previewColor;
              box.style.left = `${rect.x * width}px`;
              box.style.top = `${rect.y * height}px`;
              box.style.width = `${rect.width * width}px`;
              box.style.height = `${rect.height * height}px`;
              box.dataset.preview = '1';
              box.dataset.rectIndex = String(rectIndex);
              if (
                activeCommentId !== null &&
                typeof activeCommentId === 'number'
              ) {
                box.dataset.commentId = String(activeCommentId);
              }
              highlightLayerEl.appendChild(box);
            });
          }

          updateHighlightPointerEvents();
        }

        function clearSelectionState() {
          currentSelection = null;
          if (selectionToolbarEl && selectionToolbarEl.parentNode) {
            selectionToolbarEl.parentNode.removeChild(selectionToolbarEl);
          }
          selectionToolbarEl = null;
          if (selectionPreviewEl && selectionPreviewTextEl) {
            selectionPreviewEl.style.display = 'none';
            selectionPreviewTextEl.textContent = '';
          }
          if (pageNoteHintEl) {
            pageNoteHintEl.style.display = 'block';
          }
          // Clear any preview highlights by re-rendering persisted highlights only.
          renderHighlightsForPage(currentPage);
        }

        function updateSelectionPreview() {
          if (!selectionPreviewEl || !selectionPreviewTextEl) return;
          if (!currentSelection || !currentSelection.selectedText) {
            selectionPreviewEl.style.display = 'none';
            selectionPreviewTextEl.textContent = '';
            if (pageNoteHintEl) {
              pageNoteHintEl.style.display = 'block';
            }
            return;
          }
          const raw = String(currentSelection.selectedText || '').trim();
          if (!raw) {
            selectionPreviewEl.style.display = 'none';
            selectionPreviewTextEl.textContent = '';
            if (pageNoteHintEl) {
              pageNoteHintEl.style.display = 'block';
            }
            return;
          }
          const maxLen = 200;
          const shortText =
            raw.length > maxLen ? `${raw.slice(0, maxLen)}…` : raw;
          selectionPreviewTextEl.textContent = `“${shortText}”`;
          selectionPreviewEl.style.display = 'block';
          if (pageNoteHintEl) {
            pageNoteHintEl.style.display = 'none';
          }
        }

        function showSelectionToolbar(clientRect, containerRect) {
          if (!textLayerEl || !clientRect) return;
          if (!selectionToolbarEl) {
            selectionToolbarEl = document.createElement('button');
            selectionToolbarEl.type = 'button';
            selectionToolbarEl.className = 'selection-toolbar-btn';
            selectionToolbarEl.textContent = 'Comment selection';
            selectionToolbarEl.addEventListener('click', () => {
              if (currentSelection) {
                updateSelectionPreview();
                if (commentTextInput) {
                  commentTextInput.focus();
                }
              }
            });
            textLayerEl.appendChild(selectionToolbarEl);
          }

          const toolbarWidth = 120;
          let left =
            clientRect.left -
            containerRect.left +
            clientRect.width / 2 -
            toolbarWidth / 2;
          let top = clientRect.top - containerRect.top - 28;

          if (left < 0) left = 0;
          if (top < 0) top = 0;

          selectionToolbarEl.style.left = `${left}px`;
          selectionToolbarEl.style.top = `${top}px`;
        }

        function handleTextLayerMouseUp(event) {
          if (!textLayerEl) return;
          const selection = window.getSelection
            ? window.getSelection()
            : null;
          if (!selection || selection.isCollapsed || selection.rangeCount === 0) {
            clearSelectionState();
            return;
          }

          const range = selection.getRangeAt(0);
          if (!range || !textLayerEl.contains(range.commonAncestorContainer)) {
            clearSelectionState();
            return;
          }

          const selectedText = selection.toString().trim();
          if (!selectedText) {
            clearSelectionState();
            return;
          }

          const containerRect = textLayerEl.getBoundingClientRect();
          const rects = [];
          const clientRects = Array.from(range.getClientRects());

          // Merge overlapping selection rects on each line so we don't double
          // paint the same area (which would make highlights look darker),
          // while still preserving partial-line selections.
          const lineGroups = new Map();
          clientRects.forEach((r) => {
            const midY = (r.top + r.bottom) / 2;
            const key = String(Math.round(midY / 4)); // ~4px vertical buckets
            const existing = lineGroups.get(key);
            if (existing) {
              existing.push(r);
            } else {
              lineGroups.set(key, [r]);
            }
          });

          const mergedRects = [];
          lineGroups.forEach((group) => {
            if (!Array.isArray(group) || group.length === 0) return;
            const sorted = group.slice().sort((a, b) => a.left - b.left);

            const epsilonPx = 1; // small tolerance for overlap / adjacency
            let current = {
              left: sorted[0].left,
              right: sorted[0].right,
              top: sorted[0].top,
              bottom: sorted[0].bottom,
            };

            for (let i = 1; i < sorted.length; i++) {
              const r = sorted[i];
              if (r.left <= current.right + epsilonPx) {
                // Overlapping or touching horizontally on this line; merge.
                if (r.left < current.left) current.left = r.left;
                if (r.top < current.top) current.top = r.top;
                if (r.right > current.right) current.right = r.right;
                if (r.bottom > current.bottom) current.bottom = r.bottom;
              } else {
                mergedRects.push({ ...current });
                current = {
                  left: r.left,
                  right: r.right,
                  top: r.top,
                  bottom: r.bottom,
                };
              }
            }
            mergedRects.push({ ...current });
          });

          const finalRects = mergedRects.length > 0 ? mergedRects : clientRects;

          finalRects.forEach((r) => {
            const relativeLeft = r.left - containerRect.left;
            const relativeTop = r.top - containerRect.top;
            rects.push({
              x: containerRect.width ? relativeLeft / containerRect.width : 0,
              y: containerRect.height ? relativeTop / containerRect.height : 0,
              width: containerRect.width
                ? (r.right - r.left) / containerRect.width
                : 0,
              height: containerRect.height
                ? (r.bottom - r.top) / containerRect.height
                : 0,
            });
          });

          if (!rects.length) {
            clearSelectionState();
            return;
          }

          const shouldAppend =
            event &&
            (event.ctrlKey || event.metaKey) &&
            currentSelection &&
            currentSelection.pageNumber === currentPage &&
            Array.isArray(currentSelection.rects);

          if (shouldAppend) {
            const previousText = String(
              currentSelection.selectedText || '',
            ).trim();
            let combinedText = selectedText;
            if (previousText && selectedText) {
              combinedText = `${previousText}\n...\n${selectedText}`;
            } else if (previousText) {
              combinedText = previousText;
            }
            const existingRects = currentSelection.rects.slice();
            const combinedRects = existingRects.concat(rects);
            currentSelection = {
              pageNumber: currentPage,
              selectedText: combinedText,
              rects: combinedRects,
            };
          } else {
            currentSelection = {
              pageNumber: currentPage,
              selectedText,
              rects,
            };
          }

          console.log('Viewer selection captured', currentSelection);

          updateSelectionPreview();

          const lastClientRect =
            clientRects[clientRects.length - 1] || clientRects[0];
          showSelectionToolbar(lastClientRect, containerRect);
          renderHighlightsForPage(currentPage);
        }

        function renderCommentsForPage(pageNum) {
          if (!commentsBody) return;
          commentsBody.innerHTML = '';

          if (!Array.isArray(allComments) || allComments.length === 0) {
            const empty = document.createElement('div');
            empty.className = 'comment-empty';
            empty.textContent = 'No comments for this document.';
            commentsBody.appendChild(empty);
            return;
          }

          const filtered = allComments.filter(
            (c) => c.pageNumber === pageNum,
          );

          if (filtered.length === 0) {
            const empty = document.createElement('div');
            empty.className = 'comment-empty';
            empty.textContent = 'No comments for this page.';
            commentsBody.appendChild(empty);
            return;
          }

          for (const c of filtered) {
            const item = document.createElement('div');
            item.className = 'comment-item';
            if (typeof c.id === 'number' || typeof c.id === 'string') {
              item.dataset.commentId = String(c.id);
            }

            const colorBar = document.createElement('div');
            colorBar.className = 'comment-color-bar';
            if (c.color) {
              colorBar.style.background = getEffectiveHighlightColor(c.color);
            }
            item.appendChild(colorBar);

            // Derive a footnote-style index for this comment based on its
            // position in the full document comment list.
            let footnoteNumber = null;
            if (Array.isArray(allComments) && allComments.length > 0) {
              const idx = allComments.findIndex(
                (existing) =>
                  typeof existing.id === 'number' &&
                  typeof c.id === 'number' &&
                  existing.id === c.id,
              );
              if (idx >= 0) {
                footnoteNumber = idx + 1;
              }
            }

            // Severity + footnote badge at the top of the comment.
            if (c.severity && footnoteNumber !== null) {
              let severitySymbol = '';
              const severityValue = String(c.severity).toLowerCase();
              if (severityValue === 'low') {
                severitySymbol = '●';
              } else if (severityValue === 'medium') {
                severitySymbol = '■';
              } else if (severityValue === 'high') {
                severitySymbol = '▲';
              }
              if (severitySymbol) {
                const badge = document.createElement('div');
                badge.className = 'comment-severity-badge';
                badge.textContent = `${footnoteNumber} ${severitySymbol}`;
                item.appendChild(badge);
              }
            }

            const meta = document.createElement('div');
            meta.className = 'comment-meta';
            const parts = [];
            parts.push(`Page ${c.pageNumber}`);
            if (c.author) {
              parts.push(`by ${c.author}`);
            }
            meta.textContent = parts.join(' • ');
            item.appendChild(meta);

            const isOwner =
              currentUser &&
              typeof currentUser.id === 'number' &&
              typeof c.userId === 'number' &&
              currentUser.id === c.userId;

            const canDelete = isOwner || typeof c.userId !== 'number';

            if (canDelete && typeof c.id !== 'undefined') {
              const deleteBtn = document.createElement('button');
              deleteBtn.type = 'button';
              deleteBtn.className = 'comment-delete';
              deleteBtn.textContent = 'x';
              deleteBtn.addEventListener('click', async (event) => {
                event.stopPropagation();
                if (
                  !window.confirm(
                    'Delete this comment? This cannot be undone.',
                  )
                ) {
                  return;
                }

                try {
                  const res = await fetch(
                    `/api/documents/${encodeURIComponent(
                      currentDocId,
                    )}/comments/${encodeURIComponent(c.id)}`,
                    {
                      method: 'DELETE',
                    },
                  );

                  if (!res.ok && res.status !== 204) {
                    const text = await res.text().catch(() => '');
                    console.error(
                      'Failed to delete comment:',
                      res.status,
                      text,
                    );
                    window.alert(
                      'Failed to delete comment (status ' + res.status + ').',
                    );
                    return;
                  }

                  allComments = allComments.filter(
                    (existing) => existing.id !== c.id,
                  );
                  renderCommentsForPage(currentPage);
                  renderHighlightsForPage(currentPage);
                } catch (err) {
                  console.error('Error deleting comment:', err);
                  window.alert(
                    'Unexpected error deleting comment. See console for details.',
                  );
                }
              });

              item.appendChild(deleteBtn);
            }

            if (c.selectedText) {
              const highlightDiv = document.createElement('div');
              highlightDiv.className = 'comment-highlight-preview';
              const rawSel = String(c.selectedText || '').trim();
              const maxLen = 160;
              const shortSel =
                rawSel.length > maxLen
                  ? `${rawSel.slice(0, maxLen)}…`
                  : rawSel;
              highlightDiv.textContent = `“${shortSel}”`;
              item.appendChild(highlightDiv);
            }

            const textDiv = document.createElement('div');
            textDiv.textContent = c.text;
            item.appendChild(textDiv);

            const badgeParts = [];
            if (c.category) {
              badgeParts.push(String(c.category));
            }
            if (c.severity) {
              badgeParts.push(`Severity: ${c.severity}`);
            }
            if (c.status) {
              badgeParts.push(`Status: ${c.status}`);
            }
            if (badgeParts.length > 0) {
              const badgesDiv = document.createElement('div');
              badgesDiv.className = 'comment-badges';
              badgesDiv.textContent = badgeParts.join(' • ');
              item.appendChild(badgesDiv);
            }

            item.addEventListener('click', () => {
              if (typeof c.id === 'number') {
                if (activeCommentId === c.id) {
                  setActiveComment(null);
                } else {
                  setActiveComment(c.id);
                }
              }
              if (
                !highlightLayerEl ||
                !canvasEl ||
                !Array.isArray(c.rects) ||
                c.rects.length === 0
              ) {
                return;
              }
              const firstRect = c.rects[0];
              if (
                !firstRect ||
                typeof firstRect.y !== 'number' ||
                typeof firstRect.height !== 'number'
              ) {
                return;
              }

              const frameEl = document.querySelector('.viewer-frame-wrapper');
              if (!frameEl) return;

              const targetY =
                firstRect.y * canvasEl.height -
                Math.max(0, (frameEl.clientHeight || 0) * 0.2);

              frameEl.scrollTo({
                top: targetY,
                behavior: 'smooth',
              });
            });

            commentsBody.appendChild(item);
          }
        }

        async function loadComments(docId) {
          currentDocId = docId;
          if (!commentsBody) return;
          try {
            const res = await fetch(
              `/api/documents/${encodeURIComponent(docId)}/comments`,
            );
            let json = null;
            try {
              json = await res.json();
            } catch {
              json = null;
            }
            if (!res.ok || !json || !Array.isArray(json.items)) {
              console.error(
                'Failed to load comments:',
                json && json.error ? json.error : res.status,
              );
              return;
            }

            allComments = json.items.map((row) => ({
              id: row.id,
              pageNumber: Number(row.pageNumber) || 1,
              text: row.text || '',
              author: row.author || '',
              userId:
                typeof row.userId === 'number' ? row.userId : undefined,
              selectedText: row.selectedText || '',
              rects: Array.isArray(row.rects) ? row.rects : undefined,
              category: row.category || '',
              severity: row.severity || '',
	              status: row.status || '',
	              color: row.color || '',
	            }));
	
	            renderCommentsForPage(currentPage);
	            renderHighlightsForPage(currentPage);
	            if (
	              editingCommentId !== null &&
	              !allComments.some(
	                (c) =>
	                  typeof c.id === 'number' &&
	                  c.id === editingCommentId,
	              )
	            ) {
	              setActiveComment(null);
	            } else if (editingCommentId !== null) {
	              setActiveComment(editingCommentId);
	            }
            if (
              activeCommentId !== null &&
              !allComments.some(
                (c) =>
                  typeof c.id === 'number' && c.id === activeCommentId,
              )
            ) {
              setActiveComment(null);
            } else if (activeCommentId !== null) {
              setActiveComment(activeCommentId);
            }
	          } catch (err) {
            console.error('Error loading comments:', err);
          }
        }

        function updateCommentSubmitState() {
          if (!commentSubmitBtn || !commentTextInput) return;
          const text =
            typeof commentTextInput.value === 'string'
              ? commentTextInput.value.trim()
              : '';
          commentSubmitBtn.disabled = text.length === 0 || !currentDocId;
        }

        async function renderPage(pageNum) {
          if (!pdfDoc || !canvasEl) return;
          if (isRendering) {
            pendingPage = pageNum;
            return;
          }

          clearSelectionState();

          isRendering = true;
          setStatus(`Loading page ${pageNum}…`, false);

          try {
            const page = await pdfDoc.getPage(pageNum);
            const viewport = page.getViewport({ scale: 1.2 });
            const context = canvasEl.getContext('2d');
            if (!context) {
              setStatus('Unable to get canvas context.', true);
              isRendering = false;
              return;
            }

            canvasEl.width = viewport.width;
            canvasEl.height = viewport.height;

            const renderContext = {
              canvasContext: context,
              viewport,
            };

            await page.render(renderContext).promise;

            if (
              textLayerEl &&
              window['pdfjsLib'] &&
              typeof window['pdfjsLib'].renderTextLayer === 'function'
            ) {
              textLayerEl.innerHTML = '';
              textLayerEl.style.width = `${viewport.width}px`;
              textLayerEl.style.height = `${viewport.height}px`;

              try {
                const textContent = await page.getTextContent();
                const task = window['pdfjsLib'].renderTextLayer({
                  textContent,
                  container: textLayerEl,
                  viewport,
                  textDivs: [],
                });
                if (task && task.promise) {
                  await task.promise;
                }
              } catch (textErr) {
                console.error('Error rendering text layer:', textErr);
              }
            }

            currentPage = pageNum;
            setStatus('', false);
          } catch (renderErr) {
            console.error('Error rendering PDF page:', renderErr);
            setStatus(
              'Failed to render PDF in viewer. See console for details.',
              true,
            );
          } finally {
            isRendering = false;
            updateControls();
            if (pendingPage !== null && pendingPage !== currentPage) {
              const next = pendingPage;
              pendingPage = null;
              renderPage(next);
            } else {
              pendingPage = null;
            }

            renderCommentsForPage(currentPage);
            renderHighlightsForPage(currentPage);
          }
        }

        try {
          const params = new URLSearchParams(window.location.search);
          const docId = (params.get('doc') || '').trim();
          if (!docId) {
            setStatus('Missing document id (?doc=...).', true);
            return;
          }

          if (metaEl) {
            metaEl.textContent = `Document: ${docId}`;
          }

          setStatus('Fetching pre-signed URL…', false);

          const res = await fetch(
            `/api/documents/${encodeURIComponent(docId)}/presigned-url`,
          );

          let json = null;
          try {
            json = await res.json();
          } catch {
            json = null;
          }

          if (!res.ok || !json || typeof json.url !== 'string') {
            const message =
              json && json.error
                ? json.error
                : `Failed to load PDF (status ${res.status}).`;
            setStatus(message, true);
            return;
          }

          const url = json.url;
          if (!canvasEl) {
            setStatus('Viewer canvas is not available.', true);
            return;
          }

          if (!window['pdfjsLib']) {
            setStatus('PDF viewer library is not available.', true);
            return;
          }

          try {
            try {
              const sessionRes = await fetch('/api/auth/session');
              if (sessionRes.ok) {
                const sessionJson = await sessionRes.json().catch(() => null);
                if (sessionJson && sessionJson.authenticated && sessionJson.user) {
                  currentUser = sessionJson.user;
                }
              }
            } catch (sessionErr) {
              console.error('Error loading current user session:', sessionErr);
            }

            try {
              const paletteRes = await fetch('/api/viewer/highlights');
              if (paletteRes.ok) {
                const paletteJson = await paletteRes.json().catch(() => null);
                if (
                  paletteJson &&
                  Array.isArray(paletteJson.colors) &&
                  paletteJson.colors.length > 0
                ) {
                  highlightColors = paletteJson.colors.filter(
                    (c) => typeof c === 'string' && c.trim().length > 0,
                  );
                }
                if (
                  paletteJson &&
                  typeof paletteJson.opacity === 'number' &&
                  Number.isFinite(paletteJson.opacity)
                ) {
                  highlightOpacity = paletteJson.opacity;
                }
              }
            } catch (paletteErr) {
              console.error('Error loading highlight palette:', paletteErr);
            }

            if (highlightColors.length === 0) {
              highlightColors = ['#FACC15', '#22C55E', '#F97316'];
            }

            colorSwatchEls.forEach((el, index) => {
              if (!el) return;
              const color = highlightColors[index];
              if (color) {
                el.style.background = color;
              } else {
                el.style.background = '#ffffff';
              }
            });

            if (eraserSwatchEl) {
              eraserSwatchEl.style.borderStyle = 'dashed';
            }

            setActiveHighlightIndex(0);

            const pdfjsLib = window['pdfjsLib'];
            const loadingTask = pdfjsLib.getDocument({ url });
            pdfDoc = await loadingTask.promise;
            totalPages = typeof pdfDoc.numPages === 'number' ? pdfDoc.numPages : 0;
            await renderPage(1);
            // Load comments after initial render so we can show page 1 comments.
            await loadComments(docId);
          } catch (renderErr) {
            console.error('Error rendering PDF:', renderErr);
            setStatus(
              'Failed to render PDF in viewer. See console for details.',
              true,
            );
          }

          // Capture mouseup anywhere and, if the selection is inside the
          // text layer, treat it as a text selection for highlighting.
          document.addEventListener('mouseup', (event) => {
            if (!textLayerEl) return;
            const selection = window.getSelection
              ? window.getSelection()
              : null;
            if (
              !selection ||
              selection.isCollapsed ||
              selection.rangeCount === 0
            ) {
              return;
            }
            const range = selection.getRangeAt(0);
            if (!range) return;
            if (!textLayerEl.contains(range.commonAncestorContainer)) {
              return;
            }
            handleTextLayerMouseUp(event);
          });

          document.addEventListener('selectionchange', () => {
            // We no longer clear currentSelection on selectionchange; this
            // event is kept only for potential future diagnostics.
          });

          if (prevBtn) {
            prevBtn.addEventListener('click', () => {
              if (currentPage > 1) {
                renderPage(currentPage - 1);
              }
            });
          }

          if (nextBtn) {
            nextBtn.addEventListener('click', () => {
              if (totalPages && currentPage < totalPages) {
                renderPage(currentPage + 1);
              }
            });
          }

          updateControls();

          if (commentTextInput) {
            commentTextInput.addEventListener('input', () => {
              if (commentErrorEl) {
                commentErrorEl.textContent = '';
              }
              updateCommentSubmitState();
            });
            commentTextInput.addEventListener('focus', () => {
              if (
                currentSelection &&
                currentSelection.pageNumber === currentPage &&
                Array.isArray(currentSelection.rects) &&
                currentSelection.rects.length > 0
              ) {
                renderHighlightsForPage(currentPage);
              }
            });
          }

          if (commentCategorySelect) {
            commentCategorySelect.addEventListener('change', () => {
              const categoryVal = String(
                (commentCategorySelect).value || '',
              ).trim();
              applyCategoryColor(categoryVal);
            });
          }

          if (commentSubmitBtn) {
            commentSubmitBtn.addEventListener('click', async () => {
              if (!commentTextInput || !currentDocId) return;
              const text = commentTextInput.value.trim();
              if (!text) {
                if (commentErrorEl) {
                  commentErrorEl.textContent = 'Comment text is required.';
                }
                updateCommentSubmitState();
                return;
              }

              try {
                commentSubmitBtn.disabled = true;
                if (commentErrorEl) {
                  commentErrorEl.textContent = '';
                }

                const payload = {
                  pageNumber: currentPage,
                  text,
                };

                if (
                  currentSelection &&
                  currentSelection.selectedText &&
                  Array.isArray(currentSelection.rects) &&
                  currentSelection.rects.length > 0
                ) {
                  payload.selectedText = currentSelection.selectedText;
                  payload.rects = currentSelection.rects;
                }

                if (commentCategorySelect) {
                  const categoryVal = String(
                    (commentCategorySelect).value || '',
                  ).trim();
                  if (categoryVal) {
                    payload.category = categoryVal;
                  }
                }

                if (commentSeveritySelect) {
                  const severityVal = String(
                    (commentSeveritySelect).value || '',
                  ).trim();
                  if (severityVal) {
                    payload.severity = severityVal;
                  }
                }

                if (commentStatusSelect) {
                  const statusVal = String(
                    (commentStatusSelect).value || '',
                  ).trim();
                  if (statusVal) {
                    payload.status = statusVal;
                  }
                }

                if (activeHighlightColor) {
                  payload.color = activeHighlightColor;
                }

                let res;
                let json;

                const isEditing =
                  editingCommentId !== null &&
                  allComments.some(
                    (c) =>
                      typeof c.id === 'number' && c.id === editingCommentId,
                  );

                if (isEditing) {
                  const existing = allComments.find(
                    (c) =>
                      typeof c.id === 'number' && c.id === editingCommentId,
                  );

                  let mergedRects;
                  if (
                    existing &&
                    currentSelection &&
                    currentSelection.pageNumber === currentPage &&
                    Array.isArray(currentSelection.rects) &&
                    currentSelection.rects.length > 0
                  ) {
                    const existingRects = Array.isArray(existing.rects)
                      ? existing.rects.slice()
                      : [];
                    mergedRects = existingRects.concat(
                      currentSelection.rects,
                    );
                  }

                  const patchBody = {
                    text: payload.text,
                    category: payload.category,
                    severity: payload.severity,
                    status: payload.status,
                    color: payload.color,
                  };

                  if (mergedRects) {
                    patchBody.rects = mergedRects;
                  }

                  res = await fetch(
                    `/api/documents/${encodeURIComponent(
                      currentDocId,
                    )}/comments/${encodeURIComponent(editingCommentId)}`,
                    {
                      method: 'PATCH',
                      headers: {
                        'Content-Type': 'application/json',
                      },
                      body: JSON.stringify(patchBody),
                    },
                  );

                  json = null;
                  try {
                    json = await res.json();
                  } catch {
                    json = null;
                  }
                } else {
                  res = await fetch(
                    `/api/documents/${encodeURIComponent(
                      currentDocId,
                    )}/comments`,
                    {
                      method: 'POST',
                      headers: {
                        'Content-Type': 'application/json',
                      },
                      body: JSON.stringify(payload),
                    },
                  );

                  json = null;
                  try {
                    json = await res.json();
                  } catch {
                    json = null;
                  }
                }

                if (!res.ok) {
                  const msg =
                    json && json.error
                      ? json.error
                      : `Failed to save comment (status ${res.status}).`;
                  if (commentErrorEl) {
                    commentErrorEl.textContent = msg;
                  }
                  updateCommentSubmitState();
                  return;
                }

                if (
                  editingCommentId !== null &&
                  res.status === 204
                ) {
                  const idx = allComments.findIndex(
                    (c) =>
                      typeof c.id === 'number' &&
                      c.id === editingCommentId,
                  );
                  if (idx >= 0) {
                    const existing = allComments[idx];
                    existing.text = payload.text || existing.text || '';
                    existing.category = payload.category || '';
                    existing.severity = payload.severity || '';
                    existing.status = payload.status || '';
                    existing.color =
                      payload.color || existing.color || '';
                    if (
                      currentSelection &&
                      currentSelection.pageNumber === currentPage &&
                      Array.isArray(currentSelection.rects) &&
                      currentSelection.rects.length > 0
                    ) {
                      const existingRects = Array.isArray(existing.rects)
                        ? existing.rects.slice()
                        : [];
                      existing.rects = existingRects.concat(
                        currentSelection.rects,
                      );
                    }
                  }
                  clearSelectionState();
                  setActiveComment(editingCommentId);
                  updateCommentSubmitState();
                  renderCommentsForPage(currentPage);
                  renderHighlightsForPage(currentPage);
                } else if (json && editingCommentId === null) {
                  const newComment = {
                    id: json.id,
                    pageNumber:
                      typeof json.pageNumber === 'number'
                        ? json.pageNumber
                        : currentPage,
                    text: json.text || text,
                    author: json.author || '',
                    selectedText: json.selectedText || '',
                    rects: Array.isArray(json.rects)
                      ? json.rects
                      : currentSelection &&
                        Array.isArray(currentSelection.rects)
                      ? currentSelection.rects
                      : undefined,
                    category: json.category || '',
                    severity: json.severity || '',
                    status: json.status || '',
                    color: json.color || activeHighlightColor || '',
                  };
                  allComments.push(newComment);

                  commentTextInput.value = '';
                  clearSelectionState();
                  updateCommentSubmitState();
                  renderCommentsForPage(currentPage);
                  renderHighlightsForPage(currentPage);
                }
              } catch (err) {
                console.error('Error saving comment:', err);
                if (commentErrorEl) {
                  commentErrorEl.textContent =
                    'Unexpected error saving comment. See console for details.';
                }
              } finally {
                updateCommentSubmitState();
              }
            });
          }
        } catch (err) {
          console.error('Error initializing viewer:', err);
          setStatus(
            'Unexpected error loading PDF. See console for details.',
            true,
          );
        }
      })();
    </script>
  </body>
  </html>
