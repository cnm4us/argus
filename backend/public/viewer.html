<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Argus – Document Viewer</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
      body {
        margin: 0;
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
          sans-serif;
        background: #f3f4f6;
        color: #111827;
      }
      .viewer-container {
        display: flex;
        flex-direction: column;
        height: 100vh;
      }
      .viewer-header {
        padding: 0.6rem 0.9rem;
        background: #111827;
        color: #e5e7eb;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }
      .viewer-title {
        font-size: 0.95rem;
        font-weight: 600;
      }
      .viewer-meta {
        font-size: 0.8rem;
        opacity: 0.9;
      }
      .viewer-status {
        padding: 0.5rem 0.9rem;
        font-size: 0.85rem;
      }
      .viewer-status.error {
        color: #b91c1c;
      }
      .viewer-controls {
        padding: 0 0.9rem 0.4rem;
        display: flex;
        align-items: center;
        gap: 0.5rem;
        font-size: 0.85rem;
      }
      .viewer-controls button {
        padding: 0.25rem 0.6rem;
        border-radius: 4px;
        border: 1px solid #d1d5db;
        background: #e5e7eb;
        cursor: pointer;
      }
      .viewer-controls button:disabled {
        background: #f3f4f6;
        color: #9ca3af;
        cursor: default;
      }
      .viewer-frame-wrapper {
        flex: 1 1 auto;
        background: #111827;
        display: flex;
        justify-content: flex-start;
        align-items: flex-start;
        overflow: auto;
        padding: 0.5rem;
      }
      .viewer-doc {
        flex: 1 1 auto;
        display: flex;
        justify-content: center;
      }
      .viewer-comments {
        flex: 0 0 260px;
        max-width: 320px;
        margin-left: 0.75rem;
        background: #f9fafb;
        border-radius: 4px;
        padding: 0.5rem 0.6rem;
        box-shadow: 0 0 4px rgba(0, 0, 0, 0.15);
        display: flex;
        flex-direction: column;
        height: 100%;
        box-sizing: border-box;
      }
      .comments-header {
        font-size: 0.85rem;
        font-weight: 600;
        color: #374151;
        margin-bottom: 0.35rem;
      }
      .comments-body {
        flex: 1 1 auto;
        overflow-y: auto;
        font-size: 0.85rem;
      }
      .comments-input {
        margin-top: 0.35rem;
        border-top: 1px solid #e5e7eb;
        padding-top: 0.35rem;
        display: flex;
        flex-direction: column;
        gap: 0.25rem;
      }
      .comments-input textarea {
        width: 100%;
        min-height: 3rem;
        resize: vertical;
        padding: 0.3rem 0.4rem;
        border-radius: 4px;
        border: 1px solid #d1d5db;
        font: inherit;
        box-sizing: border-box;
      }
      .comments-input-footer {
        display: flex;
        justify-content: flex-end;
        align-items: center;
        gap: 0.25rem;
        font-size: 0.8rem;
      }
      .comments-input-footer button {
        padding: 0.25rem 0.6rem;
        border-radius: 4px;
        border: 1px solid #15803d;
        background: #15803d;
        color: #ffffff;
        cursor: pointer;
      }
      .comments-input-footer button:disabled {
        background: #9ca3af;
        border-color: #9ca3af;
        cursor: default;
      }
      .comments-input-error {
        color: #b91c1c;
        font-size: 0.75rem;
      }
      .comment-empty {
        color: #6b7280;
        font-style: italic;
      }
      .comment-item {
        margin-bottom: 0.5rem;
        padding-bottom: 0.35rem;
        border-bottom: 1px solid #e5e7eb;
        position: relative;
        padding-right: 1.2rem;
      }
      .comment-item:last-child {
        border-bottom: none;
        padding-bottom: 0;
      }
      .comment-meta {
        font-size: 0.75rem;
        color: #6b7280;
        margin-bottom: 0.15rem;
      }
      .comments-selection-preview {
        margin-top: 0.25rem;
        padding: 0.25rem 0.35rem;
        border-radius: 4px;
        background: #f3f4f6;
        font-size: 0.75rem;
        color: #374151;
        max-height: 3.5rem;
        overflow: hidden;
      }
      .comments-selection-label {
        font-weight: 600;
        margin-bottom: 0.1rem;
      }
      .comments-selection-text {
        font-style: italic;
        color: #4b5563;
      }
      .comments-metadata-row {
        margin-top: 0.3rem;
        display: flex;
        flex-wrap: wrap;
        gap: 0.35rem;
        font-size: 0.8rem;
      }
      .comments-metadata-row label {
        display: flex;
        flex-direction: column;
        gap: 0.1rem;
      }
      .comments-metadata-row select {
        min-width: 100px;
        padding: 0.15rem 0.3rem;
        border-radius: 4px;
        border: 1px solid #d1d5db;
        font: inherit;
      }
      .comment-highlight-preview {
        margin-top: 0.1rem;
        font-size: 0.78rem;
        color: #4b5563;
        font-style: italic;
      }
      .comment-badges {
        margin-top: 0.15rem;
        font-size: 0.75rem;
        color: #4b5563;
      }
      .comment-delete {
        position: absolute;
        top: 0;
        right: 0;
        font-size: 0.75rem;
        color: #ffffff;
        cursor: pointer;
        border: none;
        background: #b91c1c;
        padding: 0 4px;
        border-radius: 4px;
      }
      .comments-toolbar {
        display: flex;
        gap: 0.25rem;
        align-items: center;
        margin-bottom: 0.35rem;
        font-size: 0.75rem;
        color: #374151;
      }
      .comments-toolbar-label {
        margin-right: 0.25rem;
      }
      .comments-color-swatch {
        width: 16px;
        height: 16px;
        border-radius: 4px;
        border: 1px solid #d1d5db;
        cursor: pointer;
        box-sizing: border-box;
      }
      .comments-color-swatch.active {
        outline: 2px solid #2563eb;
        outline-offset: 1px;
      }
      .comments-eraser-swatch {
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 0.7rem;
        background: #ffffff;
      }
      .comments-page-note-hint {
        margin-top: 0.25rem;
        font-size: 0.75rem;
        color: #6b7280;
      }
      .viewer-doc {
        flex: 1 1 auto;
        display: flex;
        justify-content: center;
      }
      .pdf-page-container {
        position: relative;
        display: inline-block;
      }
      #pdf-canvas {
        background: #ffffff;
        box-shadow: 0 0 8px rgba(0, 0, 0, 0.4);
        max-width: 100%;
        height: auto;
        display: block;
      }
      .pdf-highlight-layer {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        pointer-events: none;
        z-index: 1;
      }
      .pdf-highlight-box {
        position: absolute;
        background: transparent;
        border-radius: 2px;
      }
      .pdf-text-layer {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        pointer-events: auto;
        color: transparent;
        z-index: 2;
      }
      .pdf-text-layer span {
        position: absolute;
        white-space: pre;
        cursor: text;
        transform-origin: 0% 0%;
      }
      .selection-toolbar-btn {
        position: absolute;
        z-index: 3;
        padding: 0.1rem 0.4rem;
        font-size: 0.75rem;
        border-radius: 4px;
        border: 1px solid #6b7280;
        background: #f9fafb;
        color: #111827;
        cursor: pointer;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.25);
      }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
    <script>
      if (window['pdfjsLib']) {
        pdfjsLib.GlobalWorkerOptions.workerSrc =
          'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js';
      }
    </script>
  </head>
  <body>
    <div class="viewer-container">
      <div class="viewer-header">
        <div class="viewer-title">Argus – Document Viewer</div>
        <div class="viewer-meta" id="viewer-meta"></div>
      </div>
      <div id="viewer-status" class="viewer-status">Loading PDF…</div>
      <div class="viewer-controls">
        <button id="prev-page-btn" disabled>Prev</button>
        <span id="page-indicator">Page 1 / 1</span>
        <button id="next-page-btn" disabled>Next</button>
      </div>
      <div class="viewer-frame-wrapper">
        <div class="viewer-doc">
          <div class="pdf-page-container">
            <canvas id="pdf-canvas"></canvas>
            <div
              id="pdf-highlight-layer"
              class="pdf-highlight-layer"
            ></div>
            <div id="pdf-text-layer" class="pdf-text-layer"></div>
          </div>
        </div>
        <aside class="viewer-comments">
          <div class="comments-toolbar">
            <span class="comments-toolbar-label">Highlighter:</span>
            <div
              id="comment-color-1"
              class="comments-color-swatch"
              title="Highlighter 1"
            ></div>
            <div
              id="comment-color-2"
              class="comments-color-swatch"
              title="Highlighter 2"
            ></div>
            <div
              id="comment-color-3"
              class="comments-color-swatch"
              title="Highlighter 3"
            ></div>
            <div
              id="comment-eraser"
              class="comments-color-swatch comments-eraser-swatch"
              title="Clear color"
            >
              ×
            </div>
          </div>
          <div class="comments-header">Comments</div>
          <div id="comments-body" class="comments-body"></div>
          <div class="comments-input">
            <textarea
              id="comment-text"
              placeholder="Add a comment for this page..."
            ></textarea>
            <div
              id="comment-selection-preview"
              class="comments-selection-preview"
              style="display: none;"
            >
              <div class="comments-selection-label">Selection</div>
              <div
                id="comment-selection-text"
                class="comments-selection-text"
              ></div>
            </div>
            <div
              id="comment-page-note-hint"
              class="comments-page-note-hint"
            >
              No text selected — comment will apply to this page.
            </div>
            <div class="comments-metadata-row">
              <label for="comment-category">
                Category
                <select id="comment-category">
                  <option value="">(none)</option>
                  <option value="clinical risk">Clinical risk</option>
                  <option value="documentation">Documentation</option>
                  <option value="legal note">Legal note</option>
                  <option value="other">Other</option>
                </select>
              </label>
              <label for="comment-severity">
                Severity
                <select id="comment-severity">
                  <option value="">(none)</option>
                  <option value="low">Low</option>
                  <option value="medium">Medium</option>
                  <option value="high">High</option>
                </select>
              </label>
              <label for="comment-status">
                Status
                <select id="comment-status">
                  <option value="open">Open</option>
                  <option value="resolved">Resolved</option>
                </select>
              </label>
            </div>
            <div class="comments-input-footer">
              <div style="display: flex; flex-direction: column; align-items: flex-end; gap: 0.1rem;">
                <button id="comment-submit-btn" disabled>Add comment</button>
                <div id="comment-error" class="comments-input-error"></div>
              </div>
            </div>
          </div>
        </aside>
      </div>
    </div>

    <script>
      (async function initViewer() {
        const statusEl = document.getElementById('viewer-status');
        const canvasEl = document.getElementById('pdf-canvas');
        const metaEl = document.getElementById('viewer-meta');
        const prevBtn = document.getElementById('prev-page-btn');
        const nextBtn = document.getElementById('next-page-btn');
        const pageIndicator = document.getElementById('page-indicator');
        const commentsBody = document.getElementById('comments-body');
        const commentTextInput = document.getElementById('comment-text');
        const commentSubmitBtn = document.getElementById('comment-submit-btn');
        const commentErrorEl = document.getElementById('comment-error');
        const selectionPreviewEl = document.getElementById(
          'comment-selection-preview',
        );
        const selectionPreviewTextEl = document.getElementById(
          'comment-selection-text',
        );
        const pageNoteHintEl = document.getElementById(
          'comment-page-note-hint',
        );
        const commentCategorySelect = document.getElementById(
          'comment-category',
        );
        const commentSeveritySelect = document.getElementById(
          'comment-severity',
        );
        const commentStatusSelect = document.getElementById('comment-status');
        const textLayerEl = document.getElementById('pdf-text-layer');
        const highlightLayerEl = document.getElementById('pdf-highlight-layer');
        const colorSwatchEls = [
          document.getElementById('comment-color-1'),
          document.getElementById('comment-color-2'),
          document.getElementById('comment-color-3'),
        ];
        const eraserSwatchEl = document.getElementById('comment-eraser');

        let pdfDoc = null;
        let currentPage = 1;
        let totalPages = 0;
        let isRendering = false;
        let pendingPage = null;
        let allComments = [];
        let currentDocId = '';
        let currentSelection = null;
        let selectionToolbarEl = null;
        let currentUser = null;
        let highlightColors = [];
        let highlightOpacity = 0.35;
        let activeHighlightColor = null;

        function hexToRgba(hex, alpha) {
          if (typeof hex !== 'string') return null;
          let value = hex.trim();
          if (value.startsWith('#')) {
            value = value.slice(1);
          }
          if (value.length === 3) {
            value =
              value[0] +
              value[0] +
              value[1] +
              value[1] +
              value[2] +
              value[2];
          }
          if (value.length !== 6) return null;
          const r = parseInt(value.slice(0, 2), 16);
          const g = parseInt(value.slice(2, 4), 16);
          const b = parseInt(value.slice(4, 6), 16);
          if (
            Number.isNaN(r) ||
            Number.isNaN(g) ||
            Number.isNaN(b)
          ) {
            return null;
          }
          const a = typeof alpha === 'number' ? alpha : 0.35;
          return `rgba(${r}, ${g}, ${b}, ${a})`;
        }

        function getEffectiveHighlightColor(color) {
          const base =
            typeof color === 'string' && color.trim()
              ? color.trim()
              : highlightColors[0] || '#FACC15';
          const rgba = hexToRgba(base, highlightOpacity);
          return rgba || 'rgba(250, 204, 21, 0.35)';
        }

        function setActiveHighlightIndex(index) {
          activeHighlightColor =
            index >= 0 && index < highlightColors.length
              ? highlightColors[index]
              : null;
          colorSwatchEls.forEach((el, i) => {
            if (!el) return;
            if (i === index) {
              el.classList.add('active');
            } else {
              el.classList.remove('active');
            }
          });
          if (eraserSwatchEl) {
            if (activeHighlightColor === null) {
              eraserSwatchEl.classList.add('active');
            } else {
              eraserSwatchEl.classList.remove('active');
            }
          }
        }

        if (colorSwatchEls[0]) {
          colorSwatchEls[0].addEventListener('click', () => {
            setActiveHighlightIndex(0);
          });
        }
        if (colorSwatchEls[1]) {
          colorSwatchEls[1].addEventListener('click', () => {
            setActiveHighlightIndex(1);
          });
        }
        if (colorSwatchEls[2]) {
          colorSwatchEls[2].addEventListener('click', () => {
            setActiveHighlightIndex(2);
          });
        }
        if (eraserSwatchEl) {
          eraserSwatchEl.addEventListener('click', () => {
            setActiveHighlightIndex(-1);
          });
        }

        function setStatus(message, isError) {
          if (!statusEl) return;
          statusEl.textContent = message;
          statusEl.className = isError ? 'viewer-status error' : 'viewer-status';
        }

        function updateControls() {
          if (pageIndicator && totalPages > 0) {
            pageIndicator.textContent = `Page ${currentPage} / ${totalPages}`;
          }
          if (prevBtn) {
            prevBtn.disabled = currentPage <= 1 || totalPages === 0;
          }
          if (nextBtn) {
            nextBtn.disabled =
              totalPages === 0 || currentPage >= totalPages;
          }
        }

        function renderHighlightsForPage(pageNum) {
          if (!highlightLayerEl || !canvasEl) return;
          highlightLayerEl.innerHTML = '';

          if (!Array.isArray(allComments) || allComments.length === 0) {
            return;
          }

          const width = canvasEl.width;
          const height = canvasEl.height;
          if (!width || !height) return;

          const filtered = allComments.filter(
            (c) =>
              c.pageNumber === pageNum &&
              Array.isArray(c.rects) &&
              c.rects.length > 0,
          );

          if (filtered.length === 0) return;

          highlightLayerEl.style.width = `${width}px`;
          highlightLayerEl.style.height = `${height}px`;

          filtered.forEach((c) => {
            const rects = Array.isArray(c.rects) ? c.rects : [];
            const colorStyle = getEffectiveHighlightColor(c.color);
            rects.forEach((rect) => {
              if (
                !rect ||
                typeof rect.x !== 'number' ||
                typeof rect.y !== 'number' ||
                typeof rect.width !== 'number' ||
                typeof rect.height !== 'number'
              ) {
                return;
              }

              const box = document.createElement('div');
              box.className = 'pdf-highlight-box';
              box.style.background = colorStyle;
              box.style.left = `${rect.x * width}px`;
              box.style.top = `${rect.y * height}px`;
              box.style.width = `${rect.width * width}px`;
              box.style.height = `${rect.height * height}px`;
              highlightLayerEl.appendChild(box);
            });
          });
        }

        function clearSelectionState() {
          currentSelection = null;
          if (selectionToolbarEl && selectionToolbarEl.parentNode) {
            selectionToolbarEl.parentNode.removeChild(selectionToolbarEl);
          }
          selectionToolbarEl = null;
          if (selectionPreviewEl && selectionPreviewTextEl) {
            selectionPreviewEl.style.display = 'none';
            selectionPreviewTextEl.textContent = '';
          }
          if (pageNoteHintEl) {
            pageNoteHintEl.style.display = 'block';
          }
        }

        function updateSelectionPreview() {
          if (!selectionPreviewEl || !selectionPreviewTextEl) return;
          if (!currentSelection || !currentSelection.selectedText) {
            selectionPreviewEl.style.display = 'none';
            selectionPreviewTextEl.textContent = '';
            if (pageNoteHintEl) {
              pageNoteHintEl.style.display = 'block';
            }
            return;
          }
          const raw = String(currentSelection.selectedText || '').trim();
          if (!raw) {
            selectionPreviewEl.style.display = 'none';
            selectionPreviewTextEl.textContent = '';
            if (pageNoteHintEl) {
              pageNoteHintEl.style.display = 'block';
            }
            return;
          }
          const maxLen = 200;
          const shortText =
            raw.length > maxLen ? `${raw.slice(0, maxLen)}…` : raw;
          selectionPreviewTextEl.textContent = `“${shortText}”`;
          selectionPreviewEl.style.display = 'block';
          if (pageNoteHintEl) {
            pageNoteHintEl.style.display = 'none';
          }
        }

        function showSelectionToolbar(clientRect, containerRect) {
          if (!textLayerEl || !clientRect) return;
          if (!selectionToolbarEl) {
            selectionToolbarEl = document.createElement('button');
            selectionToolbarEl.type = 'button';
            selectionToolbarEl.className = 'selection-toolbar-btn';
            selectionToolbarEl.textContent = 'Comment selection';
            selectionToolbarEl.addEventListener('click', () => {
              if (currentSelection) {
                updateSelectionPreview();
                if (commentTextInput) {
                  commentTextInput.focus();
                }
              }
            });
            textLayerEl.appendChild(selectionToolbarEl);
          }

          const toolbarWidth = 120;
          let left =
            clientRect.left -
            containerRect.left +
            clientRect.width / 2 -
            toolbarWidth / 2;
          let top = clientRect.top - containerRect.top - 28;

          if (left < 0) left = 0;
          if (top < 0) top = 0;

          selectionToolbarEl.style.left = `${left}px`;
          selectionToolbarEl.style.top = `${top}px`;
        }

        function handleTextLayerMouseUp() {
          if (!textLayerEl) return;
          const selection = window.getSelection
            ? window.getSelection()
            : null;
          if (!selection || selection.isCollapsed || selection.rangeCount === 0) {
            clearSelectionState();
            return;
          }

          const range = selection.getRangeAt(0);
          if (!range || !textLayerEl.contains(range.commonAncestorContainer)) {
            clearSelectionState();
            return;
          }

          const selectedText = selection.toString().trim();
          if (!selectedText) {
            clearSelectionState();
            return;
          }

          const containerRect = textLayerEl.getBoundingClientRect();
          const rects = [];
          const clientRects = Array.from(range.getClientRects());

          // Merge overlapping selection rects on each line so we don't double
          // paint the same area (which would make highlights look darker),
          // while still preserving partial-line selections.
          const lineGroups = new Map();
          clientRects.forEach((r) => {
            const midY = (r.top + r.bottom) / 2;
            const key = String(Math.round(midY / 4)); // ~4px vertical buckets
            const existing = lineGroups.get(key);
            if (existing) {
              existing.push(r);
            } else {
              lineGroups.set(key, [r]);
            }
          });

          const mergedRects = [];
          lineGroups.forEach((group) => {
            if (!Array.isArray(group) || group.length === 0) return;
            const sorted = group.slice().sort((a, b) => a.left - b.left);

            const epsilonPx = 1; // small tolerance for overlap / adjacency
            let current = {
              left: sorted[0].left,
              right: sorted[0].right,
              top: sorted[0].top,
              bottom: sorted[0].bottom,
            };

            for (let i = 1; i < sorted.length; i++) {
              const r = sorted[i];
              if (r.left <= current.right + epsilonPx) {
                // Overlapping or touching horizontally on this line; merge.
                if (r.left < current.left) current.left = r.left;
                if (r.top < current.top) current.top = r.top;
                if (r.right > current.right) current.right = r.right;
                if (r.bottom > current.bottom) current.bottom = r.bottom;
              } else {
                mergedRects.push({ ...current });
                current = {
                  left: r.left,
                  right: r.right,
                  top: r.top,
                  bottom: r.bottom,
                };
              }
            }
            mergedRects.push({ ...current });
          });

          const finalRects = mergedRects.length > 0 ? mergedRects : clientRects;

          finalRects.forEach((r) => {
            const relativeLeft = r.left - containerRect.left;
            const relativeTop = r.top - containerRect.top;
            rects.push({
              x: containerRect.width ? relativeLeft / containerRect.width : 0,
              y: containerRect.height ? relativeTop / containerRect.height : 0,
              width: containerRect.width
                ? (r.right - r.left) / containerRect.width
                : 0,
              height: containerRect.height
                ? (r.bottom - r.top) / containerRect.height
                : 0,
            });
          });

          if (!rects.length) {
            clearSelectionState();
            return;
          }

          currentSelection = {
            pageNumber: currentPage,
            selectedText,
            rects,
          };

          console.log('Viewer selection captured', currentSelection);

          updateSelectionPreview();

          const lastClientRect =
            clientRects[clientRects.length - 1] || clientRects[0];
          showSelectionToolbar(lastClientRect, containerRect);
        }

        function renderCommentsForPage(pageNum) {
          if (!commentsBody) return;
          commentsBody.innerHTML = '';

          if (!Array.isArray(allComments) || allComments.length === 0) {
            const empty = document.createElement('div');
            empty.className = 'comment-empty';
            empty.textContent = 'No comments for this document.';
            commentsBody.appendChild(empty);
            return;
          }

          const filtered = allComments.filter(
            (c) => c.pageNumber === pageNum,
          );

          if (filtered.length === 0) {
            const empty = document.createElement('div');
            empty.className = 'comment-empty';
            empty.textContent = 'No comments for this page.';
            commentsBody.appendChild(empty);
            return;
          }

          for (const c of filtered) {
            const item = document.createElement('div');
            item.className = 'comment-item';
            if (typeof c.id === 'number' || typeof c.id === 'string') {
              item.dataset.commentId = String(c.id);
            }

            const meta = document.createElement('div');
            meta.className = 'comment-meta';
            const parts = [];
            parts.push(`Page ${c.pageNumber}`);
            if (c.author) {
              parts.push(`by ${c.author}`);
            }
            meta.textContent = parts.join(' • ');
            item.appendChild(meta);

            const isOwner =
              currentUser &&
              typeof currentUser.id === 'number' &&
              typeof c.userId === 'number' &&
              currentUser.id === c.userId;

            const canDelete = isOwner || typeof c.userId !== 'number';

            if (canDelete && typeof c.id !== 'undefined') {
              const deleteBtn = document.createElement('button');
              deleteBtn.type = 'button';
              deleteBtn.className = 'comment-delete';
              deleteBtn.textContent = 'x';
              deleteBtn.addEventListener('click', async (event) => {
                event.stopPropagation();
                if (
                  !window.confirm(
                    'Delete this comment? This cannot be undone.',
                  )
                ) {
                  return;
                }

                try {
                  const res = await fetch(
                    `/api/documents/${encodeURIComponent(
                      currentDocId,
                    )}/comments/${encodeURIComponent(c.id)}`,
                    {
                      method: 'DELETE',
                    },
                  );

                  if (!res.ok && res.status !== 204) {
                    const text = await res.text().catch(() => '');
                    console.error(
                      'Failed to delete comment:',
                      res.status,
                      text,
                    );
                    window.alert(
                      'Failed to delete comment (status ' + res.status + ').',
                    );
                    return;
                  }

                  allComments = allComments.filter(
                    (existing) => existing.id !== c.id,
                  );
                  renderCommentsForPage(currentPage);
                  renderHighlightsForPage(currentPage);
                } catch (err) {
                  console.error('Error deleting comment:', err);
                  window.alert(
                    'Unexpected error deleting comment. See console for details.',
                  );
                }
              });

              item.appendChild(deleteBtn);
            }

            if (c.selectedText) {
              const highlightDiv = document.createElement('div');
              highlightDiv.className = 'comment-highlight-preview';
              const rawSel = String(c.selectedText || '').trim();
              const maxLen = 160;
              const shortSel =
                rawSel.length > maxLen
                  ? `${rawSel.slice(0, maxLen)}…`
                  : rawSel;
              highlightDiv.textContent = `“${shortSel}”`;
              item.appendChild(highlightDiv);
            }

            const textDiv = document.createElement('div');
            textDiv.textContent = c.text;
            item.appendChild(textDiv);

            const badgeParts = [];
            if (c.category) {
              badgeParts.push(String(c.category));
            }
            if (c.severity) {
              badgeParts.push(`Severity: ${c.severity}`);
            }
            if (c.status) {
              badgeParts.push(`Status: ${c.status}`);
            }
            if (badgeParts.length > 0) {
              const badgesDiv = document.createElement('div');
              badgesDiv.className = 'comment-badges';
              badgesDiv.textContent = badgeParts.join(' • ');
              item.appendChild(badgesDiv);
            }

            item.addEventListener('click', () => {
              if (
                !highlightLayerEl ||
                !canvasEl ||
                !Array.isArray(c.rects) ||
                c.rects.length === 0
              ) {
                return;
              }
              const firstRect = c.rects[0];
              if (
                !firstRect ||
                typeof firstRect.y !== 'number' ||
                typeof firstRect.height !== 'number'
              ) {
                return;
              }

              const frameEl = document.querySelector('.viewer-frame-wrapper');
              if (!frameEl) return;

              const targetY =
                firstRect.y * canvasEl.height -
                Math.max(0, (frameEl.clientHeight || 0) * 0.2);

              frameEl.scrollTo({
                top: targetY,
                behavior: 'smooth',
              });
            });

            commentsBody.appendChild(item);
          }
        }

        async function loadComments(docId) {
          currentDocId = docId;
          if (!commentsBody) return;
          try {
            const res = await fetch(
              `/api/documents/${encodeURIComponent(docId)}/comments`,
            );
            let json = null;
            try {
              json = await res.json();
            } catch {
              json = null;
            }
            if (!res.ok || !json || !Array.isArray(json.items)) {
              console.error(
                'Failed to load comments:',
                json && json.error ? json.error : res.status,
              );
              return;
            }

            allComments = json.items.map((row) => ({
              id: row.id,
              pageNumber: Number(row.pageNumber) || 1,
              text: row.text || '',
              author: row.author || '',
              userId:
                typeof row.userId === 'number' ? row.userId : undefined,
              selectedText: row.selectedText || '',
              rects: Array.isArray(row.rects) ? row.rects : undefined,
              category: row.category || '',
              severity: row.severity || '',
              status: row.status || '',
              color: row.color || '',
            }));

            renderCommentsForPage(currentPage);
            renderHighlightsForPage(currentPage);
          } catch (err) {
            console.error('Error loading comments:', err);
          }
        }

        function updateCommentSubmitState() {
          if (!commentSubmitBtn || !commentTextInput) return;
          const text =
            typeof commentTextInput.value === 'string'
              ? commentTextInput.value.trim()
              : '';
          commentSubmitBtn.disabled = text.length === 0 || !currentDocId;
        }

        async function renderPage(pageNum) {
          if (!pdfDoc || !canvasEl) return;
          if (isRendering) {
            pendingPage = pageNum;
            return;
          }

          clearSelectionState();

          isRendering = true;
          setStatus(`Loading page ${pageNum}…`, false);

          try {
            const page = await pdfDoc.getPage(pageNum);
            const viewport = page.getViewport({ scale: 1.2 });
            const context = canvasEl.getContext('2d');
            if (!context) {
              setStatus('Unable to get canvas context.', true);
              isRendering = false;
              return;
            }

            canvasEl.width = viewport.width;
            canvasEl.height = viewport.height;

            const renderContext = {
              canvasContext: context,
              viewport,
            };

            await page.render(renderContext).promise;

            if (
              textLayerEl &&
              window['pdfjsLib'] &&
              typeof window['pdfjsLib'].renderTextLayer === 'function'
            ) {
              textLayerEl.innerHTML = '';
              textLayerEl.style.width = `${viewport.width}px`;
              textLayerEl.style.height = `${viewport.height}px`;

              try {
                const textContent = await page.getTextContent();
                const task = window['pdfjsLib'].renderTextLayer({
                  textContent,
                  container: textLayerEl,
                  viewport,
                  textDivs: [],
                });
                if (task && task.promise) {
                  await task.promise;
                }
              } catch (textErr) {
                console.error('Error rendering text layer:', textErr);
              }
            }

            currentPage = pageNum;
            setStatus('', false);
          } catch (renderErr) {
            console.error('Error rendering PDF page:', renderErr);
            setStatus(
              'Failed to render PDF in viewer. See console for details.',
              true,
            );
          } finally {
            isRendering = false;
            updateControls();
            if (pendingPage !== null && pendingPage !== currentPage) {
              const next = pendingPage;
              pendingPage = null;
              renderPage(next);
            } else {
              pendingPage = null;
            }

            renderCommentsForPage(currentPage);
            renderHighlightsForPage(currentPage);
          }
        }

        try {
          const params = new URLSearchParams(window.location.search);
          const docId = (params.get('doc') || '').trim();
          if (!docId) {
            setStatus('Missing document id (?doc=...).', true);
            return;
          }

          if (metaEl) {
            metaEl.textContent = `Document: ${docId}`;
          }

          setStatus('Fetching pre-signed URL…', false);

          const res = await fetch(
            `/api/documents/${encodeURIComponent(docId)}/presigned-url`,
          );

          let json = null;
          try {
            json = await res.json();
          } catch {
            json = null;
          }

          if (!res.ok || !json || typeof json.url !== 'string') {
            const message =
              json && json.error
                ? json.error
                : `Failed to load PDF (status ${res.status}).`;
            setStatus(message, true);
            return;
          }

          const url = json.url;
          if (!canvasEl) {
            setStatus('Viewer canvas is not available.', true);
            return;
          }

          if (!window['pdfjsLib']) {
            setStatus('PDF viewer library is not available.', true);
            return;
          }

          try {
            try {
              const sessionRes = await fetch('/api/auth/session');
              if (sessionRes.ok) {
                const sessionJson = await sessionRes.json().catch(() => null);
                if (sessionJson && sessionJson.authenticated && sessionJson.user) {
                  currentUser = sessionJson.user;
                }
              }
            } catch (sessionErr) {
              console.error('Error loading current user session:', sessionErr);
            }

            try {
              const paletteRes = await fetch('/api/viewer/highlights');
              if (paletteRes.ok) {
                const paletteJson = await paletteRes.json().catch(() => null);
                if (
                  paletteJson &&
                  Array.isArray(paletteJson.colors) &&
                  paletteJson.colors.length > 0
                ) {
                  highlightColors = paletteJson.colors.filter(
                    (c) => typeof c === 'string' && c.trim().length > 0,
                  );
                }
                if (
                  paletteJson &&
                  typeof paletteJson.opacity === 'number' &&
                  Number.isFinite(paletteJson.opacity)
                ) {
                  highlightOpacity = paletteJson.opacity;
                }
              }
            } catch (paletteErr) {
              console.error('Error loading highlight palette:', paletteErr);
            }

            if (highlightColors.length === 0) {
              highlightColors = ['#FACC15', '#22C55E', '#F97316'];
            }

            colorSwatchEls.forEach((el, index) => {
              if (!el) return;
              const color = highlightColors[index];
              if (color) {
                el.style.background = color;
              } else {
                el.style.background = '#ffffff';
              }
            });

            if (eraserSwatchEl) {
              eraserSwatchEl.style.borderStyle = 'dashed';
            }

            setActiveHighlightIndex(0);

            const pdfjsLib = window['pdfjsLib'];
            const loadingTask = pdfjsLib.getDocument({ url });
            pdfDoc = await loadingTask.promise;
            totalPages = typeof pdfDoc.numPages === 'number' ? pdfDoc.numPages : 0;
            await renderPage(1);
            // Load comments after initial render so we can show page 1 comments.
            await loadComments(docId);
          } catch (renderErr) {
            console.error('Error rendering PDF:', renderErr);
            setStatus(
              'Failed to render PDF in viewer. See console for details.',
              true,
            );
          }

          if (textLayerEl) {
            textLayerEl.addEventListener('mouseup', handleTextLayerMouseUp);
          }

          document.addEventListener('selectionchange', () => {
            const sel = window.getSelection ? window.getSelection() : null;
            if (!sel || sel.rangeCount === 0 || sel.isCollapsed) {
              return;
            }
            const range = sel.getRangeAt(0);
            if (!textLayerEl || !range) return;
            if (!textLayerEl.contains(range.commonAncestorContainer)) {
              clearSelectionState();
            }
          });

          if (prevBtn) {
            prevBtn.addEventListener('click', () => {
              if (currentPage > 1) {
                renderPage(currentPage - 1);
              }
            });
          }

          if (nextBtn) {
            nextBtn.addEventListener('click', () => {
              if (totalPages && currentPage < totalPages) {
                renderPage(currentPage + 1);
              }
            });
          }

          updateControls();

          if (commentTextInput) {
            commentTextInput.addEventListener('input', () => {
              if (commentErrorEl) {
                commentErrorEl.textContent = '';
              }
              updateCommentSubmitState();
            });
          }

          if (commentSubmitBtn) {
            commentSubmitBtn.addEventListener('click', async () => {
              if (!commentTextInput || !currentDocId) return;
              const text = commentTextInput.value.trim();
              if (!text) {
                if (commentErrorEl) {
                  commentErrorEl.textContent = 'Comment text is required.';
                }
                updateCommentSubmitState();
                return;
              }

              try {
                commentSubmitBtn.disabled = true;
                if (commentErrorEl) {
                  commentErrorEl.textContent = '';
                }

                const payload = {
                  pageNumber: currentPage,
                  text,
                };

                if (
                  currentSelection &&
                  currentSelection.selectedText &&
                  Array.isArray(currentSelection.rects) &&
                  currentSelection.rects.length > 0
                ) {
                  payload.selectedText = currentSelection.selectedText;
                  payload.rects = currentSelection.rects;
                }

                if (commentCategorySelect) {
                  const categoryVal = String(
                    (commentCategorySelect).value || '',
                  ).trim();
                  if (categoryVal) {
                    payload.category = categoryVal;
                  }
                }

                if (commentSeveritySelect) {
                  const severityVal = String(
                    (commentSeveritySelect).value || '',
                  ).trim();
                  if (severityVal) {
                    payload.severity = severityVal;
                  }
                }

                if (commentStatusSelect) {
                  const statusVal = String(
                    (commentStatusSelect).value || '',
                  ).trim();
                  if (statusVal) {
                    payload.status = statusVal;
                  }
                }

                if (activeHighlightColor) {
                  payload.color = activeHighlightColor;
                }

                const res = await fetch(
                  `/api/documents/${encodeURIComponent(
                    currentDocId,
                  )}/comments`,
                  {
                    method: 'POST',
                    headers: {
                      'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(payload),
                  },
                );

                let json = null;
                try {
                  json = await res.json();
                } catch {
                  json = null;
                }

                if (!res.ok) {
                  const msg =
                    json && json.error
                      ? json.error
                      : `Failed to save comment (status ${res.status}).`;
                  if (commentErrorEl) {
                    commentErrorEl.textContent = msg;
                  }
                  updateCommentSubmitState();
                  return;
                }

                const newComment = {
                  id: json.id,
                  pageNumber:
                    typeof json.pageNumber === 'number'
                      ? json.pageNumber
                      : currentPage,
                  text: json.text || text,
                  author: json.author || '',
                  selectedText: json.selectedText || '',
                  rects: Array.isArray(json.rects)
                    ? json.rects
                    : currentSelection && Array.isArray(currentSelection.rects)
                    ? currentSelection.rects
                    : undefined,
                  category: json.category || '',
                  severity: json.severity || '',
                  status: json.status || '',
                  color: json.color || activeHighlightColor || '',
                };
                allComments.push(newComment);

                commentTextInput.value = '';
                clearSelectionState();
                updateCommentSubmitState();
                renderCommentsForPage(currentPage);
                renderHighlightsForPage(currentPage);
              } catch (err) {
                console.error('Error saving comment:', err);
                if (commentErrorEl) {
                  commentErrorEl.textContent =
                    'Unexpected error saving comment. See console for details.';
                }
              } finally {
                updateCommentSubmitState();
              }
            });
          }
        } catch (err) {
          console.error('Error initializing viewer:', err);
          setStatus(
            'Unexpected error loading PDF. See console for details.',
            true,
          );
        }
      })();
    </script>
  </body>
  </html>
