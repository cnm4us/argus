<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Argus – Search</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
      body {
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
          sans-serif;
        margin: 0;
        padding: 1.5rem;
        background: #f5f5f5;
      }
      .navbar {
        background: #111827;
        color: #e5e7eb;
        padding: 0.5rem 1rem;
        display: flex;
        gap: 1rem;
      }
      .navbar a {
        color: #e5e7eb;
        text-decoration: none;
        font-size: 0.9rem;
      }
      .navbar a.active {
        font-weight: 600;
        text-decoration: underline;
      }
      .container {
        max-width: 960px;
        margin: 0 auto;
        background: #fff;
        padding: 1.5rem;
        border-radius: 8px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }
      h1 {
        margin-top: 0;
      }
      .filters {
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
        margin-bottom: 0.75rem;
      }
      .filter-group {
        border: 1px solid #d1d5db;
        border-radius: 6px;
        padding: 0.75rem 0.9rem;
        background: #f9fafb;
      }
      .filter-group-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 0.1rem;
      }
      .filter-group-title {
        font-size: 0.85rem;
        font-weight: 600;
        color: #374151;
        text-transform: uppercase;
        letter-spacing: 0.03em;
      }
      .filter-group-toggle {
        background: transparent;
        border: none;
        color: #374151;
        padding: 0.1rem 0.25rem;
        cursor: pointer;
        font-size: 1.4rem;
        line-height: 1;
      }
      .filter-group-toggle:focus-visible {
        outline: 2px solid #2563eb;
        outline-offset: 1px;
      }
      .filter-group-row {
        display: flex;
        gap: 0.75rem;
        flex-wrap: wrap;
      }
      .filter-group-row > div {
        flex: 1 1 0;
        min-width: 180px;
      }
      .filters-taxonomy {
        display: flex;
        gap: 0.75rem;
      }
      .filters-taxonomy > div {
        flex: 1;
        min-width: 0;
      }
      .filters-date-range {
        margin-top: 0.25rem;
      }
      .date-range-row {
        display: flex;
        gap: 0.75rem;
      }
      .date-range-row > div {
        flex: 0 0 auto;
      }
      .date-range-row > div:first-child {
        margin-right: 0.75rem;
      }
      .date-range-row input[type='date'] {
        max-width: 160px;
      }
      label {
        font-size: 0.85rem;
        font-weight: 500;
        display: block;
        margin-bottom: 0.25rem;
      }
      input,
      select,
      button {
        font: inherit;
      }
      input[type="text"],
      input[type="date"],
      select {
        width: 100%;
        padding: 0.35rem 0.5rem;
        border-radius: 4px;
        border: 1px solid #d1d5db;
      }
      .controls {
        margin-top: 0.5rem;
        margin-bottom: 0.75rem;
      }
      button {
        padding: 0.4rem 0.75rem;
        border-radius: 4px;
        border: none;
        background: #2563eb;
        color: #fff;
        cursor: pointer;
      }
      button:disabled {
        background: #9ca3af;
        cursor: default;
      }
      .status-line {
        font-size: 0.85rem;
        margin-bottom: 0.5rem;
      }
      .status-line.error {
        color: #b91c1c;
      }
      table {
        width: 100%;
        border-collapse: collapse;
        margin-top: 0.5rem;
      }
      th,
      td {
        padding: 0.5rem 0.75rem;
        border-bottom: 1px solid #e5e7eb;
        font-size: 0.9rem;
      }
      th {
        text-align: left;
        background: #f3f4f6;
      }
      th.sortable {
        cursor: pointer;
        user-select: none;
      }
      th.date-col,
      td.date-col {
        white-space: nowrap;
      }
      a {
        color: #2563eb;
        text-decoration: none;
      }
      a:hover {
        text-decoration: underline;
      }
      .text-row {
        border: 1px solid #16a34a;
        border-radius: 4px;
        padding: 0.4rem 0.5rem 0.5rem;
        margin-bottom: 0.5rem;
        background: #ecfdf5;
        width: 40%;
        max-width: 100%;
      }
      .text-row-terms {
        display: flex;
        flex-direction: column;
        gap: 0.35rem;
      }
      .text-row-term {
        display: flex;
        align-items: center;
        gap: 0.35rem;
      }
      .text-row-term-input {
        width: 100%;
        max-width: 100%;
        box-sizing: border-box;
      }
      .text-row-controls {
        margin-top: 0.4rem;
        display: flex;
        gap: 0.35rem;
      }
      .text-row-term-remove-btn {
        padding: 0.2rem 0.45rem;
        border-radius: 4px;
        border: 1px solid #b91c1c;
        background: #b91c1c;
        color: #ffffff;
        cursor: pointer;
      }
      .text-row-remove-btn {
        padding: 0.2rem 0.45rem;
        border-radius: 4px;
        border: 1px solid #b91c1c;
        background: #b91c1c;
        color: #ffffff;
        cursor: pointer;
      }
      .text-row-controls button {
        background: #111827;
        border: 1px solid #111827;
        color: #ffffff;
      }
      #add_text_row_btn {
        background: #15803d;
        border: 1px solid #15803d;
        color: #ffffff;
      }
    </style>
  </head>
  <body>
    <div class="navbar">
      <a href="/login.html">Login</a>
      <a href="/register.html">Register</a>
      <a href="/documents.html">Documents</a>
      <a href="/search.html" class="active">Search</a>
      <a href="/openai-documents.html">OpenAI</a>
      <a href="/admin-modules.html">Admin</a>
      <a href="#" id="logout-link">Logout</a>
    </div>
    <div class="container">
      <h1>Argus – Search (DB)</h1>
      <p>
        Filter documents using local metadata stored in the Argus database.
      </p>

      <div class="filters">
        <div class="filter-group" id="section_documents">
          <div class="filter-group-header">
            <div class="filter-group-title">Documents</div>
            <button
              type="button"
              class="filter-group-toggle"
              data-section="documents"
              aria-expanded="false"
              aria-controls="section_documents_content"
            >
              ▸
            </button>
          </div>
          <div
            class="filter-group-content"
            id="section_documents_content"
          >
            <div class="filter-group-row">
              <div>
                <label for="document_type">Document Type</label>
                <select id="document_type" name="document_type">
                <option value="">Any</option>
                <option value="unclassified">unclassified</option>
                <option value="office_visit">office_visit</option>
                <option value="telehealth_visit">telehealth_visit</option>
                <option value="telephone_encounter">telephone_encounter</option>
                <option value="medication_refill">medication_refill</option>
                <option value="imaging_report">imaging_report</option>
                <option value="lab_result">lab_result</option>
                <option value="procedure_note">procedure_note</option>
                <option value="referral">referral</option>
                <option value="patient_message">patient_message</option>
                <option value="provider_message">provider_message</option>
                <option value="triage_note">triage_note</option>
                <option value="emergency_room_note">emergency_room_note</option>
                <option value="hospitalization_note">hospitalization_note</option>
                <option value="discharge_summary">discharge_summary</option>
                <option value="care_plan">care_plan</option>
                <option value="external_specialist_note">
                  external_specialist_note
                </option>
                <option value="legal_document">legal_document</option>
              </select>
              </div>
              <div>
                <label for="provider_name">Provider Name</label>
                <select id="provider_name" name="provider_name">
                  <option value="">Any</option>
                </select>
              </div>
              <div>
                <label for="clinic_or_facility">Clinic or Facility</label>
                <select id="clinic_or_facility" name="clinic_or_facility">
                  <option value="">Any</option>
                </select>
              </div>
            </div>
          </div>
        </div>
        <div class="filter-group" id="section_encounters">
          <div class="filter-group-header">
            <div class="filter-group-title">Encounters</div>
            <button
              type="button"
              class="filter-group-toggle"
              data-section="encounters"
              aria-expanded="false"
              aria-controls="section_encounters_content"
            >
              ▸
            </button>
          </div>
          <div
            class="filter-group-content"
            id="section_encounters_content"
          >
            <div class="filters-taxonomy">
              <div>
                <label for="taxonomy_category">Category</label>
                <select id="taxonomy_category" name="taxonomy_category">
                  <option value="">Any</option>
                </select>
              </div>
              <div>
                <label for="taxonomy_keyword">Keyword</label>
                <select id="taxonomy_keyword" name="taxonomy_keyword">
                  <option value="">Any</option>
                </select>
              </div>
              <div>
                <label for="taxonomy_subkeyword">Subkeyword</label>
                <select id="taxonomy_subkeyword" name="taxonomy_subkeyword">
                  <option value="">Any</option>
                </select>
              </div>
            </div>
          </div>
        </div>
        <div class="filter-group" id="section_text">
          <div class="filter-group-header">
            <div class="filter-group-title">Text Search</div>
            <button
              type="button"
              class="filter-group-toggle"
              data-section="text"
              aria-expanded="false"
              aria-controls="section_text_content"
            >
              ▸
            </button>
          </div>
          <div
            class="filter-group-content"
            id="section_text_content"
          >
            <div class="filters-taxonomy" id="text_search_container">
              <div
                style="
                  flex: 1 1 0;
                  min-width: 0;
                "
              >
                <label style="margin-bottom: 0.25rem; display: block">
                  Rows (rows = AND, boxes = OR)
                </label>
                <div id="text_rows"></div>
                <button
                  type="button"
                  id="add_text_row_btn"
                  style="margin-top: 0.35rem"
                >
                  + Add row
                </button>
                <div
                  id="text_search_message"
                  style="margin-top: 0.25rem; font-size: 0.8rem; color: #b91c1c"
                ></div>
              </div>
              <div
                style="
                  flex: 1 1 0;
                  min-width: 0;
                  display: flex;
                  flex-direction: column;
                  align-items: flex-start;
                  margin-top: 0.1rem;
                "
              >
                <label
                  for="saved_search_select"
                  style="margin-bottom: 0.15rem"
                >
                  Saved Searches
                </label>
                <select
                  id="saved_search_select"
                  name="saved_search_select"
                  style="width: 100%"
                >
                  <option value="">Select saved search…</option>
                </select>
                <div
                  style="
                    display: flex;
                    justify-content: flex-end;
                    gap: 0.35rem;
                    width: 100%;
                    margin-top: 0.25rem;
                  "
                >
                  <button
                    type="button"
                    id="save_search_btn"
                    style="padding: 0.35rem 0.6rem"
                  >
                    Save
                  </button>
                  <button
                    type="button"
                    id="delete_saved_search_btn"
                    style="padding: 0.35rem 0.6rem; background: #b91c1c"
                    disabled
                  >
                    Delete
                  </button>
                </div>
              </div>
            </div>
          </div>
        </div>
        <div class="filter-group" id="section_dates">
          <div class="filter-group-header">
            <div class="filter-group-title">Date Range</div>
            <button
              type="button"
              class="filter-group-toggle"
              data-section="dates"
              aria-expanded="false"
              aria-controls="section_dates_content"
            >
              ▸
            </button>
          </div>
          <div
            class="filter-group-content"
            id="section_dates_content"
          >
            <div class="filters-date-range">
              <div class="date-range-row">
                <div>
                  <label for="date_from">From</label>
                  <input id="date_from" type="date" />
                </div>
                <div>
                  <label for="date_to">To</label>
                  <input id="date_to" type="date" />
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>

      <div class="controls">
        <button id="search-btn">Search</button>
      </div>

      <div id="status" class="status-line"></div>

      <table>
        <thead>
          <tr>
            <th class="sortable date-col" data-sort-key="date">Date</th>
            <th class="sortable" data-sort-key="filename">File Name</th>
            <th>Details</th>
            <th>Viewer</th>
            <th class="sortable" data-sort-key="providerName">Provider</th>
            <th class="sortable" data-sort-key="clinicOrFacility">
              Clinic / Facility
            </th>
          </tr>
        </thead>
        <tbody id="results-body"></tbody>
      </table>
    </div>

    <div
      id="save_search_modal_backdrop"
      style="
        display: none;
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.3);
        z-index: 40;
      "
    >
      <div
        id="save_search_modal"
        style="
          background: #ffffff;
          border-radius: 6px;
          max-width: 320px;
          margin: 10% auto;
          padding: 1rem 1.25rem;
          box-shadow: 0 10px 25px rgba(0, 0, 0, 0.15);
        "
      >
        <h2 style="margin-top: 0; margin-bottom: 0.5rem; font-size: 1rem">
          Save search
        </h2>
        <label
          for="save_search_name"
          style="display: block; font-size: 0.85rem; font-weight: 500"
        >
          Name
        </label>
        <input
          id="save_search_name"
          type="text"
          style="
            width: 100%;
            box-sizing: border-box;
            margin-top: 0.25rem;
            padding: 0.35rem 0.5rem;
            border-radius: 4px;
            border: 1px solid #d1d5db;
            font: inherit;
          "
        />
        <div
          id="save_search_error"
          style="
            margin-top: 0.35rem;
            font-size: 0.8rem;
            min-height: 1em;
            color: #b91c1c;
          "
        ></div>
        <div
          style="
            margin-top: 0.75rem;
            display: flex;
            justify-content: flex-end;
            gap: 0.5rem;
          "
        >
          <button
            type="button"
            id="save_search_cancel_btn"
            style="background: #b91c1c; border-color: #b91c1c"
          >
            Exit
          </button>
          <button type="button" id="save_search_confirm_btn">Save</button>
        </div>
      </div>
    </div>

    <script src="/auth.js"></script>
    <script>
      const searchBtn = document.getElementById('search-btn');
      const statusEl = document.getElementById('status');
      const resultsBody = document.getElementById('results-body');
      const dateFromInput = document.getElementById('date_from');
      const dateToInput = document.getElementById('date_to');
      const documentTypeSelect = document.getElementById('document_type');
      const providerSelect = document.getElementById('provider_name');
      const clinicSelect = document.getElementById('clinic_or_facility');
      const taxonomyCategorySelect =
        document.getElementById('taxonomy_category');
      const taxonomyKeywordSelect =
        document.getElementById('taxonomy_keyword');
      const taxonomySubkeywordSelect = document.getElementById(
        'taxonomy_subkeyword',
      );
      const textRowsContainer = document.getElementById('text_rows');
      const savedSearchSelect = document.getElementById('saved_search_select');
      const textSearchMessage = document.getElementById('text_search_message');
      const saveSearchBtn = document.getElementById('save_search_btn');
      const deleteSavedSearchBtn = document.getElementById(
        'delete_saved_search_btn',
      );
      const saveSearchBackdrop = document.getElementById(
        'save_search_modal_backdrop',
      );
      const saveSearchNameInput = document.getElementById('save_search_name');
      const saveSearchError = document.getElementById('save_search_error');
      const saveSearchCancelBtn = document.getElementById(
        'save_search_cancel_btn',
      );
      const saveSearchConfirmBtn = document.getElementById(
        'save_search_confirm_btn',
      );
      const addTextRowBtn = document.getElementById('add_text_row_btn');
      const SECTION_STATE_STORAGE_KEY = 'argus.search.sectionState';
      let dateRangeInitialized = false;
      let currentItems = [];
      let currentSortKey = 'date';
      let currentSortDir = 'desc';
      let taxonomyCategories = [];
      let taxonomyKeywords = [];
      let taxonomySubkeywords = [];
      let lastTaxonomyCategoryId = '';
      let lastTaxonomyKeywordId = '';
      let lastTaxonomySubkeywordId = '';
      let textRows = [];
      let savedSearches = [];
      let pendingSaveRows = null;

      function clearTextSearchMessage() {
        if (textSearchMessage) {
          textSearchMessage.textContent = '';
        }
      }

      function loadSectionStateFromStorage() {
        try {
          const raw = window.localStorage.getItem(
            SECTION_STATE_STORAGE_KEY,
          );
          if (!raw) {
            return null;
          }
          const parsed = JSON.parse(raw);
          if (!parsed || typeof parsed !== 'object') return null;
          return parsed;
        } catch {
          return null;
        }
      }

      function saveSectionStateToStorage(state) {
        try {
          window.localStorage.setItem(
            SECTION_STATE_STORAGE_KEY,
            JSON.stringify(state),
          );
        } catch {
          // Ignore storage errors.
        }
      }

      function applySectionOpenState(sectionKey, isOpen, stateObj) {
        const container = document.getElementById(
          `section_${sectionKey}`,
        );
        if (!container) return;
        const content = container.querySelector('.filter-group-content');
        const toggle = container.querySelector('.filter-group-toggle');
        if (!content || !toggle) return;

        if (isOpen) {
          content.style.display = '';
          toggle.textContent = '▾';
          toggle.setAttribute('aria-expanded', 'true');
        } else {
          content.style.display = 'none';
          toggle.textContent = '▸';
          toggle.setAttribute('aria-expanded', 'false');
        }

        if (stateObj && typeof stateObj === 'object') {
          stateObj[sectionKey] = !!isOpen;
        }
      }

      function createTextRow(initialTerms) {
        const rowDiv = document.createElement('div');
        rowDiv.className = 'text-row';

        const termsContainer = document.createElement('div');
        termsContainer.className = 'text-row-terms';
        rowDiv.appendChild(termsContainer);

        const controlsDiv = document.createElement('div');
        controlsDiv.className = 'text-row-controls';
        rowDiv.appendChild(controlsDiv);

        function addTermInput(value) {
          const termRow = document.createElement('div');
          termRow.className = 'text-row-term';

          const input = document.createElement('input');
          input.type = 'text';
          input.placeholder = 'term';
          if (value) input.value = value;
          input.className = 'text-row-term-input';

          termRow.appendChild(input);
          termsContainer.appendChild(termRow);

          updateTermRemoveButtonsForRow(rowDiv);
          updateRowDeleteButtons();
        }

        const addTermBtn = document.createElement('button');
        addTermBtn.type = 'button';
        addTermBtn.textContent = '+ term';
        addTermBtn.addEventListener('click', () => {
          addTermInput('');
        });
        controlsDiv.appendChild(addTermBtn);

        const terms = Array.isArray(initialTerms) && initialTerms.length > 0
          ? initialTerms
          : [''];
        for (const t of terms) {
          addTermInput(t);
        }

        textRowsContainer.appendChild(rowDiv);
        updateRowDeleteButtons();
      }

      function addInitialTextRow() {
        createTextRow(['']);
      }

      function updateRowDeleteButtons() {
        const rows = textRowsContainer.querySelectorAll('.text-row');
        rows.forEach((row, index) => {
          const termsContainer = row.querySelector('.text-row-terms');
          if (!termsContainer) return;

          const termRows = termsContainer.querySelectorAll('.text-row-term');
          if (termRows.length === 0) return;

          // remove any existing row-level delete buttons
          const existingRowBtns = row.querySelectorAll('.text-row-remove-btn');
          existingRowBtns.forEach((btn) => btn.remove());

          // first row should not have a green row delete button
          if (index === 0) {
            return;
          }

          const firstTermRow = termRows[0];
          const removeRowBtn = document.createElement('button');
          removeRowBtn.type = 'button';
          removeRowBtn.textContent = '×';
          removeRowBtn.className = 'text-row-remove-btn';
          removeRowBtn.setAttribute('aria-label', 'Remove this row');
          removeRowBtn.addEventListener('click', () => {
            const allRows = textRowsContainer.querySelectorAll('.text-row');
            if (allRows.length > 1) {
              textRowsContainer.removeChild(row);
              updateRowDeleteButtons();
            }
          });
          firstTermRow.appendChild(removeRowBtn);
        });
      }

      function updateTermRemoveButtonsForRow(rowDiv) {
        const termsContainer = rowDiv.querySelector('.text-row-terms');
        if (!termsContainer) return;
        const termRows = termsContainer.querySelectorAll('.text-row-term');

        termRows.forEach((termRow, idx) => {
          let btn = termRow.querySelector('.text-row-term-remove-btn');

          if (idx === 0) {
            // first term in row: no blue term delete button
            if (btn) {
              btn.remove();
            }
          } else {
            if (!btn) {
              btn = document.createElement('button');
              btn.type = 'button';
              btn.textContent = '×';
              btn.className = 'text-row-term-remove-btn';
              btn.setAttribute('aria-label', 'Remove this term');
              btn.addEventListener('click', () => {
                const termsContainerInner =
                  rowDiv.querySelector('.text-row-terms');
                if (!termsContainerInner) return;
                termsContainerInner.removeChild(termRow);
                updateTermRemoveButtonsForRow(rowDiv);
                updateRowDeleteButtons();
              });
              termRow.insertBefore(btn, termRow.firstChild);
            }
          }
        });
      }

      async function loadSavedSearches() {
        if (!savedSearchSelect) return;
        try {
          const res = await fetch('/api/search/saved');
          const json = await res.json();
          if (!res.ok) {
            console.error(
              'Failed to load saved searches:',
              json && json.error ? json.error : res.status,
            );
            return;
          }

          savedSearches = Array.isArray(json.items) ? json.items : [];

          const prevValue = savedSearchSelect.value;

          savedSearchSelect.innerHTML = '';
          const placeholder = document.createElement('option');
          placeholder.value = '';
          placeholder.textContent = 'Select saved search…';
          savedSearchSelect.appendChild(placeholder);

          for (const item of savedSearches) {
            if (!item || !item.id || !item.name) continue;
            const opt = document.createElement('option');
            opt.value = String(item.id);
            opt.textContent = item.name;
            savedSearchSelect.appendChild(opt);
          }

          if (
            prevValue &&
            Array.from(savedSearchSelect.options).some(
              (opt) => opt.value === prevValue,
            )
          ) {
            savedSearchSelect.value = prevValue;
          } else {
            savedSearchSelect.value = '';
          }

          if (deleteSavedSearchBtn) {
            deleteSavedSearchBtn.disabled = !savedSearchSelect.value;
          }
        } catch (err) {
          console.error('Error loading saved searches', err);
        }
      }

      function clearNonTextFiltersToDefaults() {
        if (documentTypeSelect) {
          documentTypeSelect.value = '';
        }
        if (providerSelect) {
          providerSelect.value = '';
        }
        if (clinicSelect) {
          clinicSelect.value = '';
        }
        if (taxonomyCategorySelect) {
          taxonomyCategorySelect.value = '';
        }
        if (taxonomyKeywordSelect) {
          taxonomyKeywordSelect.value = '';
        }
        if (taxonomySubkeywordSelect) {
          taxonomySubkeywordSelect.value = '';
        }
        if (dateFromInput) {
          dateFromInput.value = '';
        }
        if (dateToInput) {
          dateToInput.value = '';
        }
        lastTaxonomyCategoryId = '';
        lastTaxonomyKeywordId = '';
        lastTaxonomySubkeywordId = '';
      }

      function setTextRowsFromSaved(textConfig) {
        const rows = textConfig && Array.isArray(textConfig.rows)
          ? textConfig.rows
          : [];

        textRowsContainer.innerHTML = '';

        if (!rows.length) {
          addInitialTextRow();
          textRows = [];
          return;
        }

        const normalized = [];
        for (const row of rows) {
          if (!row || !Array.isArray(row.terms)) continue;
          const terms = row.terms
            .map((t) => (typeof t === 'string' ? t.trim() : ''))
            .filter((t) => t.length > 0);
          if (!terms.length) continue;
          createTextRow(terms);
          normalized.push({ terms });
        }

        if (!normalized.length) {
          textRowsContainer.innerHTML = '';
          addInitialTextRow();
          textRows = [];
        } else {
          textRows = normalized;
        }
      }

      function collectTextRowsFromDOM() {
        const rows = [];
        const rowEls = textRowsContainer.querySelectorAll('.text-row');
        rowEls.forEach((rowEl) => {
          const terms = [];
          const inputs = rowEl.querySelectorAll('input[type="text"]');
          inputs.forEach((input) => {
            const value = input.value.trim();
            if (value) terms.push(value);
          });
          if (terms.length > 0) {
            rows.push({ terms });
          }
        });
        return rows;
      }

      async function loadOptions() {
        try {
          const res = await fetch('/api/search/options');
          const json = await res.json();
          if (!res.ok) {
            console.error(
              'Failed to load search options:',
              json && json.error ? json.error : res.status,
            );
            return;
          }

          const providers = json.providers || [];
          const clinics = json.clinics || [];
          const documentTypes = json.documentTypes || [];
          taxonomyCategories = json.taxonomyCategories || [];
          taxonomyKeywords = json.taxonomyKeywords || [];
          taxonomySubkeywords = json.taxonomySubkeywords || [];

          for (const name of providers) {
            if (!name) continue;
            const opt = document.createElement('option');
            opt.value = name;
            opt.textContent = name;
            providerSelect.appendChild(opt);
          }

          for (const name of clinics) {
            if (!name) continue;
            const opt = document.createElement('option');
            opt.value = name;
            opt.textContent = name;
            clinicSelect.appendChild(opt);
          }

          if (documentTypeSelect && Array.isArray(documentTypes)) {
            const typesWithDocs = new Set(
              documentTypes
                .filter((t) => t && typeof t.id === 'string')
                .map((t) => t.id),
            );
            const opts = documentTypeSelect.querySelectorAll('option');
            opts.forEach((opt) => {
              const value = opt.value;
              if (!value) {
                // "Any" stays default.
                opt.style.color = '';
                return;
              }
              if (typesWithDocs.has(value)) {
                opt.style.color = '';
              } else {
                opt.style.color = '#9ca3af';
              }
            });
          }

          if (taxonomyCategorySelect) {
            for (const cat of taxonomyCategories) {
              if (!cat || !cat.id) continue;
              const opt = document.createElement('option');
              opt.value = cat.id;
              opt.textContent = cat.label || cat.id;
              taxonomyCategorySelect.appendChild(opt);
            }
          }

          updateTaxonomyKeywordOptions();
          updateTaxonomySubkeywordOptions();
        } catch (err) {
          console.error('Error loading search options', err);
        }
      }

      function updateTaxonomyKeywordOptions() {
        if (!taxonomyKeywordSelect) return;
        const categoryId = taxonomyCategorySelect
          ? taxonomyCategorySelect.value
          : '';

        taxonomyKeywordSelect.innerHTML = '';
        const anyOpt = document.createElement('option');
        anyOpt.value = '';
        anyOpt.textContent = 'Any mention';
        taxonomyKeywordSelect.appendChild(anyOpt);

        const filtered = taxonomyKeywords.filter((kw) =>
          categoryId ? kw.categoryId === categoryId : true,
        );

        for (const kw of filtered) {
          if (!kw || !kw.id) continue;
          const opt = document.createElement('option');
          opt.value = kw.id;
          opt.textContent = kw.label || kw.id;
          const count =
            typeof kw.docCount === 'number' && Number.isFinite(kw.docCount)
              ? kw.docCount
              : 0;
          if (count === 0) {
            opt.style.color = '#9ca3af';
          }
          taxonomyKeywordSelect.appendChild(opt);
        }

        taxonomyKeywordSelect.disabled = filtered.length === 0;
        if (taxonomyKeywordSelect.disabled) {
          taxonomyKeywordSelect.value = '';
        }

        updateTaxonomySubkeywordOptions();
      }

      function updateTaxonomySubkeywordOptions() {
        if (!taxonomySubkeywordSelect) return;
        const keywordId = taxonomyKeywordSelect
          ? taxonomyKeywordSelect.value
          : '';

        taxonomySubkeywordSelect.innerHTML = '';
        const anyOpt = document.createElement('option');
        anyOpt.value = '';
        anyOpt.textContent = 'Any';
        taxonomySubkeywordSelect.appendChild(anyOpt);

        if (!keywordId) {
          taxonomySubkeywordSelect.disabled = true;
          taxonomySubkeywordSelect.value = '';
          return;
        }

        const filtered = taxonomySubkeywords.filter(
          (sk) => sk.keywordId === keywordId,
        );

        for (const sk of filtered) {
          if (!sk || !sk.id) continue;
          const opt = document.createElement('option');
          opt.value = sk.id;
          opt.textContent = sk.label || sk.id;
          const count =
            typeof sk.docCount === 'number' && Number.isFinite(sk.docCount)
              ? sk.docCount
              : 0;
          if (count === 0) {
            opt.style.color = '#9ca3af';
          }
          taxonomySubkeywordSelect.appendChild(opt);
        }

        taxonomySubkeywordSelect.disabled = filtered.length === 0;
        if (taxonomySubkeywordSelect.disabled) {
          taxonomySubkeywordSelect.value = '';
        }
      }

      function sortItems(items) {
        const sorted = [...items];
        sorted.sort((a, b) => {
          if (currentSortKey === 'date') {
            const da = a.date || '';
            const db = b.date || '';
            if (da === db) return 0;
            return currentSortDir === 'asc' ? (da < db ? -1 : 1) : da > db ? -1 : 1;
          }

          const aVal =
            (a[currentSortKey] || '').toString().toLowerCase();
          const bVal =
            (b[currentSortKey] || '').toString().toLowerCase();

          if (aVal === bVal) return 0;
          return currentSortDir === 'asc'
            ? aVal < bVal
              ? -1
              : 1
            : aVal > bVal
            ? -1
            : 1;
        });
        return sorted;
      }

      function renderResults(items) {
        resultsBody.innerHTML = '';

        const sorted = sortItems(items);

        for (const item of sorted) {
          const tr = document.createElement('tr');

          const dateTd = document.createElement('td');
          dateTd.className = 'date-col';
          dateTd.textContent = item.date || '';
          tr.appendChild(dateTd);

          const fileTd = document.createElement('td');
          const link = document.createElement('a');
          link.href = `/api/files/${encodeURIComponent(item.fileId)}`;
          link.target = '_blank';
          link.textContent = item.filename || '(unknown)';
          fileTd.appendChild(link);
          tr.appendChild(fileTd);

          const detailsTd = document.createElement('td');
          const detailsLink = document.createElement('a');
          const categoryId = lastTaxonomyCategoryId || '';
          const keywordId = lastTaxonomyKeywordId || '';
          const subkeywordId = lastTaxonomySubkeywordId || '';
          const params = new URLSearchParams();
          params.set('id', item.id);
          if (categoryId) params.set('category_id', categoryId);
          if (keywordId) params.set('keyword_id', keywordId);
          if (subkeywordId) params.set('subkeyword_id', subkeywordId);
          // Pass text search rows (if any) so the details page can compute snippets.
          if (Array.isArray(textRows) && textRows.length > 0) {
            try {
              params.set('text', JSON.stringify({ rows: textRows }));
            } catch {
              // Ignore serialization errors; text evidence is best-effort.
            }
          }
          detailsLink.href = `/taxonomy-details.html?${params.toString()}`;
          detailsLink.textContent = 'Details';
          detailsTd.appendChild(detailsLink);
          tr.appendChild(detailsTd);

          const viewerTd = document.createElement('td');
          const viewerLink = document.createElement('a');
          viewerLink.href = `/viewer.html?doc=${encodeURIComponent(item.id)}`;
          viewerLink.target = '_blank';
          viewerLink.textContent = 'View PDF';
          viewerTd.appendChild(viewerLink);
          tr.appendChild(viewerTd);

          const providerTd = document.createElement('td');
          providerTd.textContent = item.providerName || '';
          tr.appendChild(providerTd);

          const clinicTd = document.createElement('td');
          clinicTd.textContent = item.clinicOrFacility || '';
          tr.appendChild(clinicTd);

          resultsBody.appendChild(tr);
        }
      }

      async function runSearch() {
        statusEl.textContent = 'Searching…';
        statusEl.className = 'status-line';
        searchBtn.disabled = true;

        const documentType = document.getElementById('document_type').value;
        const providerName = providerSelect.value.trim();
        const clinicOrFacility = clinicSelect.value.trim();
        const taxonomyKeywordId = taxonomyKeywordSelect
          ? taxonomyKeywordSelect.value
          : '';
        const taxonomySubkeywordId = taxonomySubkeywordSelect
          ? taxonomySubkeywordSelect.value
          : '';
        const dateFrom = dateFromInput.value;
        const dateTo = dateToInput.value;

        const taxonomyCategoryId = taxonomyCategorySelect
          ? taxonomyCategorySelect.value
          : '';

        lastTaxonomyCategoryId = taxonomyCategoryId || '';
        lastTaxonomyKeywordId = taxonomyKeywordId || '';
        lastTaxonomySubkeywordId = taxonomySubkeywordId || '';

        // Collect text search rows (rows = AND, terms in a row = OR).
        const rows = collectTextRowsFromDOM();
        textRows = rows;

        const body = {
          document_type: documentType || undefined,
          provider_name: providerName || undefined,
          clinic_or_facility: clinicOrFacility || undefined,
          taxonomy_category_id: taxonomyCategoryId || undefined,
          taxonomy_keyword_id: taxonomyKeywordId || undefined,
          taxonomy_subkeyword_id: taxonomySubkeywordId || undefined,
          date_from: dateFrom || undefined,
          date_to: dateTo || undefined,
          text: rows.length > 0 ? { rows } : undefined,
        };

        try {
          const res = await fetch('/api/search/db', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify(body),
          });
          const json = await res.json();

          if (!res.ok) {
            statusEl.textContent =
              'Search error: ' + (json.error || res.status);
            statusEl.className = 'status-line error';
            return;
          }

          const items = json.items || [];
          if (items.length === 0) {
            statusEl.textContent = 'No documents matched your filters.';
            statusEl.className = 'status-line';
          } else {
            statusEl.textContent = `Found ${items.length} document(s).`;
            statusEl.className = 'status-line';
          }

          // Initialize date picker bounds based on available data on first load with no filters or text search.
          if (
            !dateRangeInitialized &&
            !documentType &&
            !providerName &&
            !clinicOrFacility &&
            !taxonomyCategoryId &&
            !taxonomyKeywordId &&
            !taxonomySubkeywordId &&
            !dateFrom &&
            !dateTo &&
            rows.length === 0 &&
            items.length > 0
          ) {
            const dates = items
              .map((item) => item.date)
              .filter((d) => typeof d === 'string' && d.length === 10);
            if (dates.length > 0) {
              const minDate = dates.reduce((a, b) => (a < b ? a : b));
              const maxDate = dates.reduce((a, b) => (a > b ? a : b));
              dateFromInput.min = minDate;
              dateFromInput.max = maxDate;
              dateToInput.min = minDate;
              dateToInput.max = maxDate;
            }
            dateRangeInitialized = true;
          }

          currentItems = items;
          renderResults(currentItems);
        } catch (err) {
          console.error(err);
          statusEl.textContent =
            'Unexpected error running search. See console for details.';
          statusEl.className = 'status-line error';
        } finally {
          searchBtn.disabled = false;
        }
      }

      searchBtn.addEventListener('click', runSearch);

      const headerCells = document.querySelectorAll('thead th.sortable');
      headerCells.forEach((th) => {
        const key = th.getAttribute('data-sort-key');
        if (!key) return;
        th.addEventListener('click', () => {
          if (currentSortKey === key) {
            currentSortDir = currentSortDir === 'asc' ? 'desc' : 'asc';
          } else {
            currentSortKey = key;
            currentSortDir =
              key === 'date' || key === 'filename' ? 'desc' : 'asc';
          }
          renderResults(currentItems);
        });
      });

      if (taxonomyCategorySelect) {
        taxonomyCategorySelect.addEventListener('change', () => {
          updateTaxonomyKeywordOptions();
        });
      }

      if (taxonomyKeywordSelect) {
        taxonomyKeywordSelect.addEventListener('change', () => {
          updateTaxonomySubkeywordOptions();
        });
      }

      if (addTextRowBtn) {
        addTextRowBtn.addEventListener('click', () => {
          createTextRow(['']);
        });
      }

      (function initSectionToggles() {
        const defaultState = {
          documents: false,
          encounters: false,
          text: false,
          dates: false,
        };
        const stored = loadSectionStateFromStorage();
        const state =
          stored && typeof stored === 'object'
            ? { ...defaultState, ...stored }
            : { ...defaultState };

        const sectionKeys = ['documents', 'encounters', 'text', 'dates'];

        for (const key of sectionKeys) {
          applySectionOpenState(key, !!state[key], state);
        }

        const toggles = document.querySelectorAll('.filter-group-toggle');
        toggles.forEach((btn) => {
          const sectionKey = btn.getAttribute('data-section');
          if (!sectionKey) return;
          btn.addEventListener('click', () => {
            const currentOpen = !!state[sectionKey];
            const nextOpen = !currentOpen;
            applySectionOpenState(sectionKey, nextOpen, state);
            saveSectionStateToStorage(state);
          });
        });
      })();

      if (saveSearchBtn) {
        saveSearchBtn.addEventListener('click', () => {
          clearTextSearchMessage();
          const rows = collectTextRowsFromDOM();
          if (!rows.length) {
            if (textSearchMessage) {
              textSearchMessage.textContent =
                'Enter at least one term before saving a search.';
            }
            return;
          }

          pendingSaveRows = rows;
          if (!saveSearchBackdrop || !saveSearchNameInput || !saveSearchError) {
            return;
          }
          saveSearchError.textContent = '';
          saveSearchNameInput.value = '';
          saveSearchBackdrop.style.display = 'block';
          saveSearchNameInput.focus();
        });
      }

      if (saveSearchCancelBtn) {
        saveSearchCancelBtn.addEventListener('click', () => {
          pendingSaveRows = null;
          if (saveSearchBackdrop) {
            saveSearchBackdrop.style.display = 'none';
          }
        });
      }

      if (saveSearchConfirmBtn) {
        saveSearchConfirmBtn.addEventListener('click', async () => {
          if (!pendingSaveRows || !Array.isArray(pendingSaveRows)) {
            if (saveSearchError) {
              saveSearchError.textContent =
                'Nothing to save. Close and try again.';
            }
            return;
          }

          if (!saveSearchNameInput || !saveSearchError) {
            return;
          }

          const name = saveSearchNameInput.value.trim();
          if (!name) {
            saveSearchError.textContent = 'Please enter a name.';
            return;
          }

          try {
            saveSearchConfirmBtn.disabled = true;
            const res = await fetch('/api/search/saved', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
              },
              body: JSON.stringify({
                name,
                text: { rows: pendingSaveRows },
              }),
            });

            let json = null;
            try {
              json = await res.json();
            } catch {
              json = null;
            }

            if (!res.ok) {
              const message =
                json && json.error
                  ? json.error
                  : 'Failed to save search.';
              saveSearchError.textContent = message;
              saveSearchConfirmBtn.disabled = false;
              return;
            }

            await loadSavedSearches();
            if (savedSearchSelect && json && json.id) {
              savedSearchSelect.value = String(json.id);
            }

            pendingSaveRows = null;
            if (saveSearchBackdrop) {
              saveSearchBackdrop.style.display = 'none';
            }
          } catch (err) {
            console.error('Error saving search', err);
            if (saveSearchError) {
              saveSearchError.textContent =
                'Unexpected error saving search. See console.';
            }
          } finally {
            saveSearchConfirmBtn.disabled = false;
          }
        });
      }

      if (deleteSavedSearchBtn) {
        deleteSavedSearchBtn.addEventListener('click', async () => {
          if (!savedSearchSelect) return;
          const value = savedSearchSelect.value;
          if (!value) return;

          const id = Number.parseInt(value, 10);
          if (!Number.isFinite(id)) return;

          const match = savedSearches.find(
            (item) => Number.parseInt(String(item.id), 10) === id,
          );
          const name = match && match.name ? match.name : '';

          const confirmed = window.confirm(
            name
              ? `Delete saved search "${name}"?`
              : 'Delete this saved search?',
          );
          if (!confirmed) return;

          try {
            deleteSavedSearchBtn.disabled = true;
            const res = await fetch(
              `/api/search/saved/${encodeURIComponent(id)}`,
              {
                method: 'DELETE',
              },
            );
            if (!res.ok && res.status !== 204 && res.status !== 404) {
              console.error(
                'Failed to delete saved search; status:',
                res.status,
              );
            }
          } catch (err) {
            console.error('Error deleting saved search', err);
          } finally {
            await loadSavedSearches();
            if (savedSearchSelect) {
              savedSearchSelect.value = '';
            }
            if (deleteSavedSearchBtn) {
              deleteSavedSearchBtn.disabled = true;
            }
          }
        });
      }

      if (savedSearchSelect) {
        savedSearchSelect.addEventListener('change', () => {
          const value = savedSearchSelect.value;

          if (deleteSavedSearchBtn) {
            deleteSavedSearchBtn.disabled = !value;
          }

          if (!value) {
            return;
          }

          const id = Number.parseInt(value, 10);
          if (!Number.isFinite(id)) {
            return;
          }

          const match = savedSearches.find(
            (item) => Number.parseInt(String(item.id), 10) === id,
          );
          if (!match || !match.text) {
            return;
          }

          clearNonTextFiltersToDefaults();
          setTextRowsFromSaved(match.text);
          runSearch();
        });
      }

      // Initial load: options + saved searches + search with no filters.
      loadOptions();
      loadSavedSearches();
      addInitialTextRow();
      runSearch();
    </script>
  </body>
</html>
